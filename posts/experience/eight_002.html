<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/favicon.ico"><title>八股文-002 | 前端档案</title><meta name="description" content="前端通关宝典">
    <link rel="modulepreload" href="/assets/app.77cde27d.js"><link rel="modulepreload" href="/assets/eight_002.html.54c0c735.js"><link rel="modulepreload" href="/assets/eight_002.html.a00dcd3e.js">
    <link rel="stylesheet" href="/assets/style.39d5bbe5.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="/logo.png" alt="前端档案"><span class="site-name can-hide">前端档案</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/posts/guide/" class="" aria-label="指南"><!--[--><!--]--> 指南 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/fe/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/be/" class="" aria-label="后端"><!--[--><!--]--> 后端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/base/" class="" aria-label="基础"><!--[--><!--]--> 基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/resume/" class="" aria-label="简历"><!--[--><!--]--> 简历 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/experience/" class="router-link-active" aria-label="面经"><!--[--><!--]--> 面经 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/tools/" class="" aria-label="工具"><!--[--><!--]--> 工具 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/posts/guide/" class="" aria-label="指南"><!--[--><!--]--> 指南 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/fe/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/be/" class="" aria-label="后端"><!--[--><!--]--> 后端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/base/" class="" aria-label="基础"><!--[--><!--]--> 基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/resume/" class="" aria-label="简历"><!--[--><!--]--> 简历 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/experience/" class="router-link-active" aria-label="面经"><!--[--><!--]--> 面经 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/tools/" class="" aria-label="工具"><!--[--><!--]--> 工具 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">面经 <span class="down arrow"></span></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/posts/experience/" class="router-link-active sidebar-item" aria-label="面经汇总"><!--[--><!--]--> 面经汇总 <!--[--><!--]--></a><!----></li><li><a href="/posts/experience/collect.html" class="sidebar-item" aria-label="面试题汇总"><!--[--><!--]--> 面试题汇总 <!--[--><!--]--></a><!----></li><li><a href="/posts/experience/companies.html" class="sidebar-item" aria-label="北京互联网企业"><!--[--><!--]--> 北京互联网企业 <!--[--><!--]--></a><!----></li><li><a href="/posts/experience/eight_001.html" class="sidebar-item" aria-label="八股文-001"><!--[--><!--]--> 八股文-001 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="八股文-002"><!--[--><!--]--> 八股文-002 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/posts/experience/eight_002.html#_1-html中居中的方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.HTML中居中的方式"><!--[--><!--]--> 1.HTML中居中的方式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_2-如何把行内元素转成块级元素-有多少种方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.如何把行内元素转成块级元素， 有多少种方式？"><!--[--><!--]--> 2.如何把行内元素转成块级元素， 有多少种方式？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_3-display-none-与-visibility-hidden-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.display:none 与 visibility：hidden 的区别"><!--[--><!--]--> 3.display:none 与 visibility：hidden 的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_4-什么是伪类-和-伪元素-有哪些-区别是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.什么是伪类 和 伪元素，有哪些，区别是什么？"><!--[--><!--]--> 4.什么是伪类 和 伪元素，有哪些，区别是什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_5-box-sizing是什么-各个参数含义" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.box-sizing是什么，各个参数含义"><!--[--><!--]--> 5.box-sizing是什么，各个参数含义 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/posts/experience/eight_002.html#属性值" class="router-link-active router-link-exact-active sidebar-item" aria-label="属性值"><!--[--><!--]--> 属性值 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_6-js中map和filter区别-是否会改变原数组" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.JS中map和filter区别，是否会改变原数组？"><!--[--><!--]--> 6.JS中map和filter区别，是否会改变原数组？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_7-js中-不通过insetafter-的方式-如何在元素后插入一个新元素" class="router-link-active router-link-exact-active sidebar-item" aria-label="7.JS中，不通过insetAfter()的方式，如何在元素后插入一个新元素？"><!--[--><!--]--> 7.JS中，不通过insetAfter()的方式，如何在元素后插入一个新元素？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_8-判断一个变量是数组有几种方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="8.判断一个变量是数组有几种方式？"><!--[--><!--]--> 8.判断一个变量是数组有几种方式？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_9-js中如何区别object-和-array" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.JS中如何区别Object 和 Array？"><!--[--><!--]--> 9.JS中如何区别Object 和 Array？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_10-事件代理、事件冒泡、事件捕获是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="10.事件代理、事件冒泡、事件捕获是什么？"><!--[--><!--]--> 10.事件代理、事件冒泡、事件捕获是什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_11-axios-原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="11.axios 原理"><!--[--><!--]--> 11.axios 原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_12-什么是跨域-如何处理" class="router-link-active router-link-exact-active sidebar-item" aria-label="12.什么是跨域？如何处理？"><!--[--><!--]--> 12.什么是跨域？如何处理？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_13-你知道哪些http状态码" class="router-link-active router-link-exact-active sidebar-item" aria-label="13.你知道哪些HTTP状态码？"><!--[--><!--]--> 13.你知道哪些HTTP状态码？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_14-简述路由原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="14.简述路由原理"><!--[--><!--]--> 14.简述路由原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_15-简述mobx原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="15.简述mobx原理"><!--[--><!--]--> 15.简述mobx原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_16-简述promise原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="16.简述promise原理"><!--[--><!--]--> 16.简述promise原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_17-简述async-await原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="17.简述async await原理"><!--[--><!--]--> 17.简述async await原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_18-什么是虚拟dom" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.什么是虚拟DOM？"><!--[--><!--]--> 18.什么是虚拟DOM？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_19-vue如何实现路由拦截" class="router-link-active router-link-exact-active sidebar-item" aria-label="19.vue如何实现路由拦截？"><!--[--><!--]--> 19.vue如何实现路由拦截？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_20-react题-class中请求应该放在哪个生命周期" class="router-link-active router-link-exact-active sidebar-item" aria-label="20.React题，class中请求应该放在哪个生命周期？"><!--[--><!--]--> 20.React题，class中请求应该放在哪个生命周期？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_21-react题-函数组件中如何执行异步请求操作" class="router-link-active router-link-exact-active sidebar-item" aria-label="21.React题，函数组件中如何执行异步请求操作？"><!--[--><!--]--> 21.React题，函数组件中如何执行异步请求操作？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_22-react题-usestate为什么不能放在条件里" class="router-link-active router-link-exact-active sidebar-item" aria-label="22.React题，useState为什么不能放在条件里？"><!--[--><!--]--> 22.React题，useState为什么不能放在条件里？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_22-react题-setstate是异步还是同步" class="router-link-active router-link-exact-active sidebar-item" aria-label="22.React题，setState是异步还是同步？"><!--[--><!--]--> 22.React题，setState是异步还是同步？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_24-react题-component和purecomponent区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="24.React题，component和PureComponent区别？"><!--[--><!--]--> 24.React题，component和PureComponent区别？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_25-react题-如何用useeffect实现class的生命周期" class="router-link-active router-link-exact-active sidebar-item" aria-label="25.React题，如何用useEffect实现class的生命周期？"><!--[--><!--]--> 25.React题，如何用useEffect实现class的生命周期？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_26-react题-usememo与usecallback区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="26.React题，useMemo与useCallback区别？"><!--[--><!--]--> 26.React题，useMemo与useCallback区别？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/experience/eight_002.html#_27-顺时针循环打印二维数组" class="router-link-active router-link-exact-active sidebar-item" aria-label="27.顺时针循环打印二维数组"><!--[--><!--]--> 27.顺时针循环打印二维数组 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/posts/experience/fengchao.html" class="sidebar-item" aria-label="丰巢科技"><!--[--><!--]--> 丰巢科技 <!--[--><!--]--></a><!----></li><li><a href="/posts/experience/others.html" class="sidebar-item" aria-label="其他公司"><!--[--><!--]--> 其他公司 <!--[--><!--]--></a><!----></li><li><a href="/posts/experience/self-introduction.html" class="sidebar-item" aria-label="面试的时候如何自我介绍"><!--[--><!--]--> 面试的时候如何自我介绍 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="八股文-002" tabindex="-1"><a class="header-anchor" href="#八股文-002" aria-hidden="true">#</a> 八股文-002</h1><p>2021中高级前端面试题总结</p><h2 id="_1-html中居中的方式" tabindex="-1"><a class="header-anchor" href="#_1-html中居中的方式" aria-hidden="true">#</a> <strong>1.HTML中居中的方式</strong></h2><ul><li>text-align:center方式，水平居中块级元素中的行内元素，如inline，inline-block</li><li>margin:0 auto方式，这种对齐方式要求内部元素是块级元素，并且不能脱离文档流（如设置position:absolute）,否则无效。</li><li>display:table-cell，配合width，text-align:center,vertical-align:middle让大小不固定元素垂直居中,这个方式将要对其的元素设置成为一个td，float、absolute等属性都会影响它的实现，不响应margin属性;</li><li>垂直居中，行内元素的垂直居中把height和line-height的值设置成一样的即可。</li><li>使用css3的translate水平垂直居中元素 ，设置top：50%，left：50%，然后使用transform来向左向上偏移半个内元素的宽和高。</li><li>使用css3计算的方式居中元素calc，例如：left: calc(50% - 元素固定宽度);</li><li>使用弹性盒(display：flex)，display:flex;justify-content:center;align-items:center;</li></ul><h2 id="_2-如何把行内元素转成块级元素-有多少种方式" tabindex="-1"><a class="header-anchor" href="#_2-如何把行内元素转成块级元素-有多少种方式" aria-hidden="true">#</a> <strong>2.如何把行内元素转成块级元素， 有多少种方式？</strong></h2><ul><li>使用display:block</li><li>使用float</li><li>使用position（absolute和fixed）</li></ul><h2 id="_3-display-none-与-visibility-hidden-的区别" tabindex="-1"><a class="header-anchor" href="#_3-display-none-与-visibility-hidden-的区别" aria-hidden="true">#</a> <strong>3.display:none 与 visibility：hidden 的区别</strong></h2><ul><li>如果给一个元素设置了display: none，那么该元素以及它的所有后代元素都会隐藏，它是前端开发人员使用频率最高的一种隐藏方式。隐藏后的元素无法点击，无法使用屏幕阅读器等辅助设备访问，占据的空间消失。</li><li>给元素设置visibility: hidden也可以隐藏这个元素，但是隐藏元素仍需占用与未隐藏时一样的空间，也就是说虽然元素不可见了，但是仍然会影响页面布局。</li><li>visibility具有继承性，给父元素设置visibility:hidden;子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。这个和display: none有着质的区别。</li><li>visibility: hidden不会影响计数器的计数，如图所示，visibility: hidden虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样。</li></ul><h2 id="_4-什么是伪类-和-伪元素-有哪些-区别是什么" tabindex="-1"><a class="header-anchor" href="#_4-什么是伪类-和-伪元素-有哪些-区别是什么" aria-hidden="true">#</a> <strong>4.什么是伪类 和 伪元素，有哪些，区别是什么？</strong></h2><p>伪类用于定义元素的特殊状态。例如，它可以用于：</p><ul><li>设置鼠标悬停在元素上时的样式</li><li>为已访问和未访问链接设置不同的样式</li><li>设置元素获得焦点时的样式</li></ul><table><thead><tr><th>选择器</th><th>例子</th><th>例子描述</th></tr></thead><tbody><tr><td>:active</td><td>a:active</td><td>选择活动的链接。</td></tr><tr><td>:checked</td><td>input:checked</td><td>选择每个被选中的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:disabled</td><td>input:disabled</td><td>选择每个被禁用的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:empty</td><td>p:empty</td><td>选择没有子元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:enabled</td><td>input:enabled</td><td>选择每个已启用的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:first-child</td><td>p:first-child</td><td>选择作为其父的首个子元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:first-of-type</td><td>p:first-of-type</td><td>选择作为其父的首个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:focus</td><td>input:focus</td><td>选择获得焦点的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:hover</td><td>a:hover</td><td>选择鼠标悬停其上的链接。</td></tr><tr><td>:in-range</td><td>input:in-range</td><td>选择具有指定范围内的值的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:invalid</td><td>input:invalid</td><td>选择所有具有无效值的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:lang(language)</td><td>p:lang(it)</td><td>选择每个 lang 属性值以 &quot;it&quot; 开头的 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:last-child</td><td>p:last-child</td><td>选择作为其父的最后一个子元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:last-of-type</td><td>p:last-of-type</td><td>选择作为其父的最后一个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:link</td><td>a:link</td><td>选择所有未被访问的链接。</td></tr><tr><td>:not(selector)</td><td>:not(p)</td><td>选择每个非 <code>&lt;p&gt;</code> 元素的元素。</td></tr><tr><td>:nth-child(n)</td><td>p:nth-child(2)</td><td>选择作为其父的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:nth-last-child(n)</td><td>p:nth-last-child(2)</td><td>选择作为父的第二个子元素的每个<code>&lt;p&gt;</code>元素，从最后一个子元素计数。</td></tr><tr><td>:nth-last-of-type(n)</td><td>p:nth-last-of-type(2)</td><td>选择作为父的第二个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素，从最后一个子元素计数</td></tr><tr><td>:nth-of-type(n)</td><td>p:nth-of-type(2)</td><td>选择作为其父的第二个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:only-of-type</td><td>p:only-of-type</td><td>选择作为其父的唯一 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:only-child</td><td>p:only-child</td><td>选择作为其父的唯一子元素的 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:optional</td><td>input:optional</td><td>选择不带 &quot;required&quot; 属性的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:out-of-range</td><td>input:out-of-range</td><td>选择值在指定范围之外的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:read-only</td><td>input:read-only</td><td>选择指定了 &quot;readonly&quot; 属性的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:read-write</td><td>input:read-write</td><td>选择不带 &quot;readonly&quot; 属性的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:required</td><td>input:required</td><td>选择指定了 &quot;required&quot; 属性的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:root</td><td>root</td><td>选择元素的根元素。</td></tr><tr><td>:target</td><td>#news:target</td><td>选择当前活动的 #news 元素（单击包含该锚名称的 URL）。</td></tr><tr><td>:valid</td><td>input:valid</td><td>选择所有具有有效值的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:visited</td><td>a:visited</td><td>选择所有已访问的链接。</td></tr></tbody></table><table><thead><tr><th>选择器</th><th>例子</th><th>例子描述</th></tr></thead><tbody><tr><td>::after</td><td>p::after</td><td>在每个 <code>&lt;p&gt;</code> 元素之后插入内容。</td></tr><tr><td>::before</td><td>p::before</td><td>在每个 <code>&lt;p&gt;</code> 元素之前插入内容。</td></tr><tr><td>::first-letter</td><td>p::first-letter</td><td>选择每个 <code>&lt;p&gt;</code> 元素的首字母。</td></tr><tr><td>::first-line</td><td>p::first-line</td><td>选择每个 <code>&lt;p&gt;</code> 元素的首行。</td></tr><tr><td>::selection</td><td>p::selection</td><td>选择用户选择的元素部分。</td></tr></tbody></table><p>CSS 伪元素用于设置元素指定部分的样式。例如，它可用于：</p><ul><li>设置元素的首字母、首行的样式</li><li>在元素的内容之前或之后插入内容</li></ul><table><thead><tr><th>选择器</th><th>例子</th><th>例子描述</th></tr></thead><tbody><tr><td>:active</td><td>a:active</td><td>选择活动的链接。</td></tr><tr><td>:checked</td><td>input:checked</td><td>选择每个被选中的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:disabled</td><td>input:disabled</td><td>选择每个被禁用的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:empty</td><td>p:empty</td><td>选择没有子元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:enabled</td><td>input:enabled</td><td>选择每个已启用的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:first-child</td><td>p:first-child</td><td>选择作为其父的首个子元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:first-of-type</td><td>p:first-of-type</td><td>选择作为其父的首个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:focus</td><td>input:focus</td><td>选择获得焦点的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:hover</td><td>a:hover</td><td>选择鼠标悬停其上的链接。</td></tr><tr><td>:in-range</td><td>input:in-range</td><td>选择具有指定范围内的值的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:invalid</td><td>input:invalid</td><td>选择所有具有无效值的 <code>&lt;inuput&gt;</code> 元素。</td></tr><tr><td>:lang(language)</td><td>p:lang(it)</td><td>选择每个 lang 属性值以 &quot;it&quot; 开头的 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:last-child</td><td>p:last-child</td><td>选择作为其父的最后一个子元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:last-of-type</td><td>p:last-of-type</td><td>选择作为其父的最后一个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:link</td><td>a:link</td><td>选择所有未被访问的链接。</td></tr><tr><td>:not(selector)</td><td>:not(p)</td><td>选择每个非 <code>&lt;p&gt;</code> 元素的元素。</td></tr><tr><td>:nth-child(n)</td><td>p:nth-child(2)</td><td>选择作为其父的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:nth-last-child(n)</td><td>p:nth-last-child(2)</td><td>选择作为父的第二个子元素的每个<code>&lt;p&gt;</code>元素，从最后一个子元素计数。</td></tr><tr><td>:nth-last-of-type(n)</td><td>p:nth-last-of-type(2e&#39;f)</td><td>选择作为父的第二个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素，从最后一个子元素计数</td></tr><tr><td>:nth-of-type(n)</td><td>p:nth-of-type(2)</td><td>选择作为其父的第二个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:only-of-type</td><td>p:only-of-type</td><td>选择作为其父的唯一 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:only-child</td><td>p:only-child</td><td>选择作为其父的唯一子元素的 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>:optional</td><td>input:optional</td><td>选择不带 &quot;required&quot; 属性的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:out-of-range</td><td>input:out-of-range</td><td>选择值在指定范围之外的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:read-only</td><td>input:read-only</td><td>选择指定了 &quot;readonly&quot; 属性的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:read-write</td><td>input:read-write</td><td>选择不带 &quot;readonly&quot; 属性的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:required</td><td>input:required</td><td>选择指定了 &quot;required&quot; 属性的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:root</td><td>root</td><td>选择元素的根元素。</td></tr><tr><td>:target</td><td>#news:target</td><td>选择当前活动的 #news 元素（单击包含该锚名称的 URL）。</td></tr><tr><td>:valid</td><td>input:valid</td><td>选择所有具有有效值的 <code>&lt;input&gt;</code> 元素。</td></tr><tr><td>:visited</td><td>a:visited</td><td>选择所有已访问的链接。</td></tr></tbody></table><blockquote><p>伪类和伪元素的根本区别在于：<strong>它们是否创造了新的元素。</strong></p></blockquote><p><strong>伪类：</strong></p><blockquote><p>伪类存在的意义是为了通过选择器找到那些不存在与DOM树中的信息以及不能被常规CSS选择器获取到的信息。伪类由<strong>一个</strong>冒号<code>:</code>开头，冒号后面是伪类的名称和包含在圆括号中的可选参数。任何常规选择器可以再任何位置使用伪类。伪类语法不区别大小写。一些伪类的作用会互斥，另外一些伪类可以同时被同一个元素使用。并且，为了满足用户在操作DOM时产生的DOM结构改变，伪类也可以是动态的。 获取不存在与DOM树中的信息。比如<code>&lt;a&gt;</code>标签的<code>:link</code>、<code>visited</code>等，这些信息不存在与DOM树结构中，只能通过CSS选择器来获取； 获取不能被常规CSS选择器获取的信息。比如伪类<code>:target</code>，它的作用是匹配文档(页面)的URI中某个标志符的目标元素。</p></blockquote><p><strong>伪元素：</strong></p><blockquote><p>伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在于文档语言里的（可以理解为html源码）。比如：documen接口不提供访问元素内容的第一个字或者第一行的机制，而伪元素可以使开发者可以提取到这些信息。并且，一些伪元素可以使开发者获取到不存在于源文档中的内容（比如常见的<code>::before</code>,<code>::after</code>）。 伪元素的由<strong>两个冒号</strong><code>::</code>开头，然后是伪元素的名称。 使用两个冒号<code>::</code>是为了区别伪类和伪元素（CSS2中并没有区别）。当然，考虑到兼容性，CSS2中已存的伪元素仍然可以使用一个冒号<code>:</code>的语法，但是CSS3中新增的伪元素必须使用两个冒号<code>::</code>。 一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后。 注：不排除未来会加入同时使用多个伪元素的机制。</p></blockquote><p>第一段话是伪元素的清晰定义，也是伪元素与伪类最大的区别。简单来说，伪元素创建了一个虚拟容器，这个容器不包含任何DOM元素，但是可以包含内容。另外，开发者还可以为伪元素定制样式。</p><p>最后，总结一下伪类与伪元素的特性及其区别：</p><ol><li>伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；</li><li>伪元素本质上是创建了一个有内容的虚拟容器；</li><li>CSS3中伪类和伪元素的语法不同；</li><li>可以同时使用多个伪类，而只能同时使用一个伪元素；</li></ol><h2 id="_5-box-sizing是什么-各个参数含义" tabindex="-1"><a class="header-anchor" href="#_5-box-sizing是什么-各个参数含义" aria-hidden="true">#</a> <strong>5.box-sizing是什么，各个参数含义</strong></h2><p><code>box-sizing</code>属性定义了 <a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Glossary/User_agent" target="_blank" rel="noopener noreferrer">user agent<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>应该如何计算一个元素的总宽度和总高度。</p><p>在 <a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="noopener noreferrer">CSS 盒子模型<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>的默认定义里，你对一个元素所设置的 <code>width</code> 与 <code>height</code> 只会应用到这个元素的内容区。如果这个元素有任何的 <code>border</code> 或 <code>padding</code> ，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。</p><h3 id="属性值" tabindex="-1"><a class="header-anchor" href="#属性值" aria-hidden="true">#</a> 属性值</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>content-box
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>默认值，标准盒子模型。 <code>width</code> 与 <code>height</code> 只包括内容的宽和高， 不包括边框（border），内边距（padding），外边距（margin）。注意: 内边距、边框和外边距都在这个盒子的外部。 比如说，<code>.box {width: 350px; border: 10px solid black;}</code> 在浏览器中的渲染的实际宽度将是 370px。</p><p>尺寸计算公式：</p><p><code>width</code> = 内容的宽度</p><p><code>height</code> = 内容的高度</p><p>宽度和高度的计算值都不包含内容的边框（border）和内边距（padding）。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>border-box
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>width</code> 和 <code>height</code> 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="noopener noreferrer">盒模型<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。注意，填充和边框将在盒子内 , 例如, <code>.box {width: 350px; border: 10px solid black;}</code> 导致在浏览器中呈现的宽度为350px的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。</p><p>尺寸计算公式：</p><p><em><code>width</code></em> <em>= border + padding + 内容的宽度</em></p><p><em><code>height</code></em> <em>= border + padding + 内容的高度</em></p><p>**注1：**border-box不包含margin。</p><p>**注2：**对于新的web站点，你可能希望首先将box-sizing设置为border-box，如下所示： * { box-sizing: border-box; } 这使得处理元素大小的工作变得容易得多，并且通常消除了在布局内容时可能遇到的许多陷阱。然而，在某些情况下，你应谨慎使用这个属性。例如： 你正在编写一个将由其他人使用的共享组件库，如果他们网站的其余部分没有设置此值，他们可能会发现很难使用你的组件库。</p><h2 id="_6-js中map和filter区别-是否会改变原数组" tabindex="-1"><a class="header-anchor" href="#_6-js中map和filter区别-是否会改变原数组" aria-hidden="true">#</a> <strong>6.JS中map和filter区别，是否会改变原数组？</strong></h2><p><strong>map()</strong> 会根据提供的函数对指定序列做映射。</p><blockquote><p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p></blockquote><p><strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p><blockquote><p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 true 或 false，最后将返回 true 的元素放到新列表中。</p></blockquote><p>map和filter都不会改变原数组。</p><h2 id="_7-js中-不通过insetafter-的方式-如何在元素后插入一个新元素" tabindex="-1"><a class="header-anchor" href="#_7-js中-不通过insetafter-的方式-如何在元素后插入一个新元素" aria-hidden="true">#</a> 7.JS中，不通过insetAfter()的方式，如何在元素后插入一个新元素？</h2><p>检查目标元素是不是parent的最后一个子元素，即比较parent元素的lastChild属性值与目标元素是否存在“等于“关系：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>lastChild <span class="token operator">==</span> targetElement<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>如果是，就用appendChild方法把新元素追加到parent元素上，这样新元素恰好被插入到目标元素之后：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>parent<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>newElement<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>如果不是， 就把新元素插入到目标元素和目标元素的下一个元素中间。目标元素下一个兄弟元素即目标元素的nextSibling属性。用insertBerfore方法把新元素插入到目标元素的下一个兄弟元素之间。</p><h2 id="_8-判断一个变量是数组有几种方式" tabindex="-1"><a class="header-anchor" href="#_8-判断一个变量是数组有几种方式" aria-hidden="true">#</a> 8.判断一个变量是数组有几种方式？</h2><ol><li>instanceof ，原型判断，写法：变量 instanceof Array</li><li><strong>proto</strong>，原型判断，写法：变量.<strong>proto</strong> === Array.prototype</li><li>constructor，原型判断，写法：变量.constructor === Array</li><li>Object.prototype.toString，通过object类型的副属性class去判断的其中函数的class是Function，结果是[object Function]， 普通的对象是Object，结果是[object Object]，写法：Object.prototype.toString.call(变量) === &#39;[object Array]&#39;</li><li>Array.isArray，es6新增的方法，写法：Array.isArray(变量)</li></ol><h2 id="_9-js中如何区别object-和-array" tabindex="-1"><a class="header-anchor" href="#_9-js中如何区别object-和-array" aria-hidden="true">#</a> 9.JS中如何区别Object 和 Array？</h2><p>typeof一般测试基本类型（Undefined、Null、Boolean、Number、String)，对引用类型（数组，对象，函数），数组和对象返回object，函数引用类型返回Function。typeof对于区分数组和对象是没有用的。</p><p>1.通过ES6中的Array.isArray来识别</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">//true</span>
Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment">//false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>2.通过instanceof来识别</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>   <span class="token comment">//true</span>
<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>   <span class="token comment">//false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>3.通过调用constructor来识别</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span>constructor    <span class="token comment">//返回object</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>constructor    <span class="token comment">//返回Array</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>4.通过Object.prototype.toString.call方法来识别</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">//[&quot;object Array&quot;]</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token comment">//[&quot;object Object&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>5.通过isPrototypeOf()函数来识别</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">//true表示是数组，false不是数组</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="_10-事件代理、事件冒泡、事件捕获是什么" tabindex="-1"><a class="header-anchor" href="#_10-事件代理、事件冒泡、事件捕获是什么" aria-hidden="true">#</a> 10.事件代理、事件冒泡、事件捕获是什么？</h2><p>**事件代理：**又称之为事件委托，是JavaScript中常用绑定事件的常用技巧。“事件代理”是把原本需要绑定在子元素的响应事件（click、keydown......）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。</p><p><strong>事件代理优点：</strong></p><ol><li>可以大量节省内存占用，减少事件注册；</li><li>可以实现当新增子对象时无需再次对其绑定（动态绑定事件）。</li></ol><p>一个事件触发后，会在子元素和父元素之间传播（propagation），这种传播分成三个阶段：</p><ul><li>**捕获阶段：**从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件；</li><li>**目标阶段：**在目标节点上触发，称为“目标阶段”</li><li>**冒泡阶段：**从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层。</li></ul><h2 id="_11-axios-原理" tabindex="-1"><a class="header-anchor" href="#_11-axios-原理" aria-hidden="true">#</a> 11.axios 原理</h2><p>axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。axios可以用在浏览器和 node.js 中是因为，它会自动判断当前环境是什么，如果是浏览器，就会基于XMLHttpRequests实现axios。如果是node.js环境，就会基于node内置核心模块http实现axios。</p><ul><li>XMLHttpRequest 是浏览器内置的一个对象，它为客户端提供了在客户端和服务器之间传输数据的功能。</li><li>process 对象是node内置的一个全局变量，提供有关信息，控制当前 Node.js 进程。通过判断process是否存在，来判断是否是node环境。</li></ul><p><strong>特征：</strong></p><ol><li>Make XMLHttpRequests from the browser（从浏览器发起XMLHttpRequests请求）</li><li>Make http requests from node.js（从node.js发起http请求）</li><li>Supports the Promise API（支持PromiseAPI）</li><li>Intercept request and response（拦截请求和响应）</li><li>Transform request and response data（转换请求和响应数据）</li><li>Cancel requests（取消请求）</li><li>Automatic transforms for JSON data（自动转换json数据）</li><li>Client side support for protecting against XSRF（客户端支持自动防止XSRF）</li></ol><h2 id="_12-什么是跨域-如何处理" tabindex="-1"><a class="header-anchor" href="#_12-什么是跨域-如何处理" aria-hidden="true">#</a> 12.什么是跨域？如何处理？</h2><p>当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为跨域。</p><blockquote><p>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。</p></blockquote><p><strong>非同源限制：</strong></p><ol><li>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</li><li>无法接触非同源网页的 DOM</li><li>无法向非同源地址发送 AJAX 请求</li></ol><p><strong>解决方法：</strong></p><p><strong>1. 设置document.domain解决无法读取非同源网页的 Cookie问题</strong></p><blockquote><p>因为浏览器是通过document.domain属性来检查两个页面是否同源，因此只要通过设置相同的document.domain，两个页面就可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景。）</p></blockquote><p><strong>2. 跨文档通信 API：window.postMessage()</strong></p><blockquote><p>调用postMessage方法实现父窗口<a href="https://link.zhihu.com/?target=http%3A//test1.com" target="_blank" rel="noopener noreferrer">http://test1.com<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>向子窗口<a href="https://link.zhihu.com/?target=http%3A//test2.com" target="_blank" rel="noopener noreferrer">http://test2.com<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>发消息（子窗口同样可以通过该方法发送消息给父窗口），它可用于解决以下方面的问题： 1.页面和其打开的新窗口的数据传递 2.多窗口之间消息传递 3.页面与嵌套的iframe消息传递 4.上面三个场景的跨域数据传递</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 父窗口打开一个子窗口</span>
<span class="token keyword">var</span> openWindow <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&#39;http://test2.com&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;title&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 父窗口向子窗口发消息(第一个参数代表发送的内容，第二个参数代表接收消息窗口的url)</span>
openWindow<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">&#39;Nice to meet you!&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;http://test2.com&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>调用message事件，监听对方发送的消息</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 监听 message 消息</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;message&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// e.source 发送消息的窗口</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// e.origin 消息发向的网址</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// e.data   发送的消息</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>3. JSONP</strong></p><blockquote><p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。 核心思想：网页通过添加一个 <code>&lt;script&gt;</code> 元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 原生实现</span>
<span class="token comment">// 向服务器发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;http://test.com/api/data?callback=dosomething&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
 
<span class="token comment">// 处理服务器返回回调函数的数据</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span><span class="token operator">&gt;</span>
    <span class="token keyword">function</span> <span class="token function">dosomething</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 处理获得的数据</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token comment">// JQuery ajax</span>
$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">&#39;http://www.test.com:8080/login&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&#39;get&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">dataType</span><span class="token operator">:</span> <span class="token string">&#39;jsonp&#39;</span><span class="token punctuation">,</span>  <span class="token comment">// 请求方式为jsonp</span>
    <span class="token literal-property property">jsonpCallback</span><span class="token operator">:</span> <span class="token string">&quot;handleCallback&quot;</span><span class="token punctuation">,</span>    <span class="token comment">// 自定义回调函数名</span>
    <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Vue</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$http<span class="token punctuation">.</span><span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token string">&#39;http://www.domain2.com:8080/login&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">jsonp</span><span class="token operator">:</span> <span class="token string">&#39;handleCallback&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// React</span>
<span class="token keyword">import</span> JsonP <span class="token keyword">from</span> <span class="token string">&#39;jsonp&#39;</span>
<span class="token keyword">class</span> <span class="token class-name">Axios</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token function">JsonP</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>url<span class="token punctuation">,</span><span class="token punctuation">{</span>
                <span class="token literal-property property">param</span><span class="token operator">:</span><span class="token string">&#39;callback&#39;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token string">&#39;success&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Axios<span class="token punctuation">.</span><span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">url</span><span class="token operator">:</span><span class="token string">&#39;path&#39;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>   
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br></div></div><p><strong>4.CORS</strong></p><blockquote><p>CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。 普通跨域请求：只需服务器端设置Access-Control-Allow-Origin 带cookie跨域请求：前后端都需要进行设置（根据xhr.withCredentials字段判断是否带有cookie）</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 原生ajax</span>
<span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// IE8/9需用window.XDomainRequest兼容</span>
 
<span class="token comment">// 前端设置是否带cookie</span>
xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&#39;post&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;http://www.domain2.com:8080/login&#39;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">&#39;Content-Type&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;application/x-www-form-urlencoded&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&#39;user=admin&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">// jQuery ajax </span>
$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
   <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">&#39;http://www.test.com:8080/login&#39;</span><span class="token punctuation">,</span>
   <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&#39;get&#39;</span><span class="token punctuation">,</span>
   <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token literal-property property">xhrFields</span><span class="token operator">:</span> <span class="token punctuation">{</span>
       <span class="token literal-property property">withCredentials</span><span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token comment">// 前端设置是否带cookie</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token literal-property property">crossDomain</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>   <span class="token comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// vue-resource</span>
Vue<span class="token punctuation">.</span>http<span class="token punctuation">.</span>options<span class="token punctuation">.</span>credentials <span class="token operator">=</span> <span class="token boolean">true</span>


<span class="token comment">//axios </span>
axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h2 id="_13-你知道哪些http状态码" tabindex="-1"><a class="header-anchor" href="#_13-你知道哪些http状态码" aria-hidden="true">#</a> 13.你知道哪些HTTP状态码？</h2><table><thead><tr><th>状态码</th><th>类别</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>Informational（信息状态码）</td><td>接受请求正在处理</td></tr><tr><td>2xx</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection（重定向状态码）</td><td>需要附加操作已完成请求</td></tr><tr><td>4xx</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><p>常用状态码：</p><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>206</td><td>Partial Content</td><td>是对资源某一部分的请求，服务器成功处理了部分GET请求，响应报文中包含由Content-Range指定范围的实体内容。</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久性重定向。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时性重定向。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与302类似。使用GET请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向，会按照浏览器标准，不会从POST变成GET。</td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求报文中存在语法错误，服务器无法理解。浏览器会像200 OK一样对待该状态吗</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证，通过HTTP认证（BASIC认证，DIGEST认证）的认证信息，若之前已进行过一次请求，则表示用户认证失败</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面。也可以在服务器拒绝请求且不想说明理由时使用</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求，也可能是web应用存在bug或某些临时故障</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr></tbody></table><h2 id="_14-简述路由原理" tabindex="-1"><a class="header-anchor" href="#_14-简述路由原理" aria-hidden="true">#</a> 14.简述路由原理</h2><p>路由分为后端路由和前端路由。</p><p><strong>后端路由</strong></p><p>又称服务器端路由，当服务器收到客户端发来的HTTP请求，就会根据请求的URL，来找到相应的映射函数，然后执行该函数，将执行结果的返回值发送给客户端。</p><p>对于最简单的静态资源服务器，可以认为，所有的URL的映射函数就是一个文件读取操作。而对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据操作，等等。然后根据读取的数据，在服务器端就使用相应的模块来对页面进行渲染后，再返回渲染完毕的页面。这种方式在早期的前端开发中非常普遍，像京东的页面就是一个后端路由，他请求的是一个页面。</p><p>优点：安全性好，SEO好。</p><p>缺点：加大服务器的压力，不利于用户体验，代码冗合。</p><p><strong>前端路由</strong></p><p>URL到函数的映射。路由的映射函数通常是进行一些DOM的显示隐藏操作。当访问不同路径时，就会显示不同的页面组件。</p><p>优点：访问不同页面时，仅仅只是变换了路径而已，没有网络延迟，提升了用户体验。</p><p>缺点：使用浏览器的前进后退时，会重新发送请求，没有合理的利用缓存，不利于SEO。</p><p><strong>前端路由主要有两种实现方案：hash、history API</strong></p><p>**hash：**hash实现就是基于location.hash来实现的，早期前端路由都是用hash。location.hash的值就是URL中#后面的内容。</p><p>**history API：**更美观的实现URL的变化，由H5提供的history API。最主要的API：history.pushState()、history.replaceState()。这两个API可以在不刷新的情况下，操作浏览器的历史记录。区别：pushState()是会增加新的历史记录，而replaceState()是替换当前的历史记录。都接受三个参数（state，title，URL）。</p><p><strong>hash和history的区别</strong></p><table><thead><tr><th>hash</th><th>history</th></tr></thead><tbody><tr><td>兼容更好</td><td>更正式美观</td></tr><tr><td>只修改#后面内容</td><td>可以设置同源下任意URL</td></tr><tr><td>新值不能与旧值相同，一样的不会触发动作将记录添加到栈中</td><td>新旧值可以相同，pushSate该添加的会添加到栈中</td></tr><tr><td>对服务器无需改动</td><td>刷新时，若服务器没有响应数据或资源，会404。需要对服务器做一些改造，对不同的路由进行相应的设置。</td></tr><tr><td>即不会发送请求</td><td>会向服务器发送请求，避免404服务器应该做处理。当匹配不到资源时，应返回同一个html页面</td></tr></tbody></table><h2 id="_15-简述mobx原理" tabindex="-1"><a class="header-anchor" href="#_15-简述mobx原理" aria-hidden="true">#</a> 15.简述mobx原理</h2><p>核心概念：observable 可观察对象</p><blockquote><p>在 mobx 中，我们需要在一个值或一个对象被改变时，触发相应的动作或响应，这种模式就是典型的观察者模式（或发布订阅模式），那么这里一个值或一个对象就是被观察者，动作或者响应充当观察者。 首先进行对象代理（proxy 或 defineProperty），这样对象就成了observable对象；其次观察者在执行主体逻辑时会访问代理对象属性，这时代理对象主动上报（reportObserved）自己到观察者的观察对象队列（observing）中，同时也会将观察者放入observable对象的观察者队列（observers）中，观察者和被观察者相互存有对方的引用，关系正式确立；最后，当设置代理对象属性时，代理对象触发（reportChanged）观察者执行主体逻辑。</p></blockquote><h2 id="_16-简述promise原理" tabindex="-1"><a class="header-anchor" href="#_16-简述promise原理" aria-hidden="true">#</a> 16.简述promise原理</h2><blockquote><p>Promise 是异步编程的一种解决方案：从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。promise有三种状态：<strong>pending(等待态)，fulfiled(成功态)，rejected(失败态)</strong>；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。</p></blockquote><p>基本过程：</p><ol><li>初始化 Promise 状态（pending）</li><li>立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理</li><li>执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）</li><li>Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。</li></ol><p><strong>真正的链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise.</strong></p><h2 id="_17-简述async-await原理" tabindex="-1"><a class="header-anchor" href="#_17-简述async-await原理" aria-hidden="true">#</a> 17.简述async await原理</h2><p>async函数就是generator函数的语法糖，将generator函数的*换成async，将yield替换成await。</p><p>async函数对generator的改进：</p><ol><li>内置执行器。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，无需手动执行 next() 方法。</li><li>更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li><li>更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li><li>返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。</li></ol><blockquote><p>Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态，但是只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器,<code>co 模块</code>就是一个著名的执行器。</p></blockquote><p>async隐式返回 Promise 作为结果的函数,那么可以简单理解为，await后面的函数执行完毕时，await会产生一个微任务(Promise.then是微任务)。但是我们要注意这个微任务产生的时机，它是执行完await之后，直接跳出async函数，执行其他代码(此处就是协程的运作，A暂停执行，控制权交给B)。其他代码执行完毕后，再回到async函数去执行剩下的代码，然后把await后面的代码注册到微任务队列当中。</p><blockquote><p>一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。协程遇到<code>yield命令</code>就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p></blockquote><h2 id="_18-什么是虚拟dom" tabindex="-1"><a class="header-anchor" href="#_18-什么是虚拟dom" aria-hidden="true">#</a> 18.什么是虚拟DOM？</h2><p>虚拟 DOM 的本质就是 JavaScript 对 象，使用 JavaScript 对象来描述 DOM 的结构。应用的各种状态变化首先作用于虚拟 DOM，最终映射 到 DOM。</p><p>前端性能优化的一个秘诀就是尽可能少地操作DOM，不仅仅是DOM相对较慢，更因为频繁变动DOM会造成浏览器的回流或者重回，这些都是性能的杀手，因此我们需要这一层抽象，在patch过程中尽可能地一次性将差异更新到DOM中，这样保证了DOM不会出现性能很差的情况。</p><p>其次，现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率.</p><p>其次，现代前端框架的一个基本要求就是无须手动操作DOM,一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。</p><h2 id="_19-vue如何实现路由拦截" tabindex="-1"><a class="header-anchor" href="#_19-vue如何实现路由拦截" aria-hidden="true">#</a> 19.vue如何实现路由拦截？</h2><p><strong>1.全局前置守卫</strong></p><p>使用<code>router.beforeEach</code>注册一个全局前置守卫：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于<strong>等待中</strong>。</p><p><strong>2.组件内的守卫</strong></p><p>在路由组件内直接定义以下路由导航守卫：</p><ul><li><code>beforeRouteEnter</code></li><li><code>beforeRouteUpdate</code> (2.2 新增)</li><li><code>beforeRouteLeave</code></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">...</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteEnter</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在渲染该组件的对应路由被 confirm 前调用</span>
    <span class="token comment">// 不！能！获取组件实例 `this`</span>
    <span class="token comment">// 因为当守卫执行前，组件实例还没被创建</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在当前路由改变，但是该组件被复用时调用</span>
    <span class="token comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span>
    <span class="token comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span>
    <span class="token comment">// 可以访问组件实例 `this`</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteLeave</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 导航离开该组件的对应路由时调用</span>
    <span class="token comment">// 可以访问组件实例 `this`</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="_20-react题-class中请求应该放在哪个生命周期" tabindex="-1"><a class="header-anchor" href="#_20-react题-class中请求应该放在哪个生命周期" aria-hidden="true">#</a> 20.React题，class中请求应该放在哪个生命周期？</h2><p>放在componentDidMount，它是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重新渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。</p><p>不建议放在constructor，constructor是做组件state初绐化工作，并不是做加载数据这工作的，constructor里也不能setState，还有加载的时间太长或者出错，页面就无法加载出来。所以有副作用的代码都会集中在componentDidMount方法里。</p><p>不建议放在componentWillMount，如果认为在componentWillMount里发起请求能提早获得结果，这种想法其实是错误的，通常componentWillMount比componentDidMount早不了多少微秒，网络上任何一点延迟，这一点差异都可忽略不计。且componentWillMount已过时。</p><h2 id="_21-react题-函数组件中如何执行异步请求操作" tabindex="-1"><a class="header-anchor" href="#_21-react题-函数组件中如何执行异步请求操作" aria-hidden="true">#</a> 21.React题，函数组件中如何执行异步请求操作？</h2><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">fetchData</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token string">&#39;请求地址&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 执行其他操作...</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>重点：不允许在<code>useEffect</code>函数中直接使用async，通过在effect内部使用异步函数来实现。</p><h2 id="_22-react题-usestate为什么不能放在条件里" tabindex="-1"><a class="header-anchor" href="#_22-react题-usestate为什么不能放在条件里" aria-hidden="true">#</a> 22.React题，useState为什么不能放在条件里？</h2><blockquote><p>只在最顶层使用 Hook，<strong>不要在循环，条件或嵌套函数中调用 Hook，</strong> 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 hook 状态的正确。</p></blockquote><p>简单来说，React 靠的是 Hook 调用的顺序知道哪个 state 对应哪个<code>useState</code>。Hook 的调用顺序在每次渲染中都是相同的，所以它能够正常工作。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// ------------</span>
<span class="token comment">// 首次渲染</span>
<span class="token comment">// ------------</span>
<span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&#39;Mary&#39;</span><span class="token punctuation">)</span>           <span class="token comment">// 1. 使用 &#39;Mary&#39; 初始化变量名为 name 的 state</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span>persistForm<span class="token punctuation">)</span>     <span class="token comment">// 2. 添加 effect 以保存 form 操作</span>
<span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&#39;Poppins&#39;</span><span class="token punctuation">)</span>        <span class="token comment">// 3. 使用 &#39;Poppins&#39; 初始化变量名为 surname 的 state</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span>updateTitle<span class="token punctuation">)</span>     <span class="token comment">// 4. 添加 effect 以更新标题</span>

<span class="token comment">// -------------</span>
<span class="token comment">// 二次渲染</span>
<span class="token comment">// -------------</span>
<span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&#39;Mary&#39;</span><span class="token punctuation">)</span>           <span class="token comment">// 1. 读取变量名为 name 的 state（参数被忽略）</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span>persistForm<span class="token punctuation">)</span>     <span class="token comment">// 2. 替换保存 form 的 effect</span>
<span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&#39;Poppins&#39;</span><span class="token punctuation">)</span>        <span class="token comment">// 3. 读取变量名为 surname 的 state（参数被忽略）</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span>updateTitle<span class="token punctuation">)</span>     <span class="token comment">// 4. 替换更新标题的 effect</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_22-react题-setstate是异步还是同步" tabindex="-1"><a class="header-anchor" href="#_22-react题-setstate是异步还是同步" aria-hidden="true">#</a> 22.React题，setState是异步还是同步？</h2><p>有时表现出异步，有时表现出同步：</p><ol><li><code>setState</code>只在合成事件和钩子函数中是“异步”的，在原生事件和<code>setTimeout</code> 中都是同步的。</li><li><code>setState</code> 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 <code>setState(partialState, callback)</code> 中的<code>callback</code>拿到更新后的结果。</li><li><code>setState</code> 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次<code>setState</code>，<code>setState</code>的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时<code>setState</code>多个不同的值，在更新时会对其进行合并批量更新。</li></ol><p>23.React题，你对shouldComponentUpdate的理解</p><p>根据 <code>shouldComponentUpdate()</code> 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。</p><p>当 props 或 state 发生变化时，<code>shouldComponentUpdate()</code> 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 <code>forceUpdate()</code> 时不会调用该方法。</p><p>此方法仅作为**<a href="https://link.zhihu.com/?target=https%3A//react.docschina.org/docs/optimizing-performance.html" target="_blank" rel="noopener noreferrer">性能优化的方式<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><strong>而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该</strong>考虑使用内置的** <strong><code>PureComponent</code></strong> <strong>组件</strong>，而不是手动编写 <code>shouldComponentUpdate()</code>。<code>PureComponent</code> 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。</p><p>如果你一定要手动编写此函数，可以将 <code>this.props</code> 与 <code>nextProps</code> 以及 <code>this.state</code> 与<code>nextState</code> 进行比较，并返回 <code>false</code> 以告知 React 可以跳过更新。请注意，返回 <code>false</code> 并不会阻止子组件在 state 更改时重新渲染。</p><p>不建议在 <code>shouldComponentUpdate()</code> 中进行深层比较或使用 <code>JSON.stringify()</code>。这样非常影响效率，且会损害性能。</p><p>目前，如果 <code>shouldComponentUpdate()</code> 返回 <code>false</code>，则不会调用 <code>UNSAFE_componentWillUpdate()</code>，<code>render()</code> 和 <code>componentDidUpdate()</code>。后续版本，React 可能会将 <code>shouldComponentUpdate</code> 视为提示而不是严格的指令，并且，当返回 <code>false</code> 时，仍可能导致组件重新渲染。</p><h2 id="_24-react题-component和purecomponent区别" tabindex="-1"><a class="header-anchor" href="#_24-react题-component和purecomponent区别" aria-hidden="true">#</a> 24.React题，component和PureComponent区别？</h2><p><code>Component</code>是<code>class</code>组件的根基，类组件一切始于<code>Component</code> ，在<code>React.Component</code>的子类中有个必须定义的 render() 函数。</p><p><code>React.PureComponent</code> 与 <code>React.Component</code> 很相似。两者的区别在于 <code>React.Component</code> 并未实现 <code>shouldComponentUpdate()</code>，而 <code>React.PureComponent</code> 中以浅层对比 prop 和 state 的方式来实现了该函数。</p><p>如果赋予 React 组件相同的 props 和 state，<code>render()</code> 函数会渲染相同的内容，那么在某些情况下使用 <code>React.PureComponent</code> 可提高性能。</p><blockquote><p>注意 <code>React.PureComponent</code> 中的 <code>shouldComponentUpdate()</code> 仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。仅在你的 props 和 state 较为简单时，才使用 <code>React.PureComponent</code>，或者在深层数据结构发生变化时调用 <code>forceUpdate()</code> 来确保组件被正确地更新。你也可以考虑使用 <a href="https://link.zhihu.com/?target=https%3A//facebook.github.io/immutable-js/" target="_blank" rel="noopener noreferrer">immutable 对象<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>加速嵌套数据的比较。 此外，<code>React.PureComponent</code> 中的 <code>shouldComponentUpdate()</code> 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。</p></blockquote><h2 id="_25-react题-如何用useeffect实现class的生命周期" tabindex="-1"><a class="header-anchor" href="#_25-react题-如何用useeffect实现class的生命周期" aria-hidden="true">#</a> 25.React题，如何用useEffect实现class的生命周期？</h2><p>1.<code>useEffect</code>实现<code>componentDidMount</code>的效果：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// TODO</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// useEffect 的第二个参数为[]时，</span>
<span class="token comment">// 表示这个effect只会在componentDidMount和componentWillUnMount的时候调用</span>
<span class="token comment">// componentWillUnMount调用的是第一个参数返回的回调</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>2.使用<code>useEffect</code>实现<code>componentDidUpdate</code>的效果：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">handleStatusChange</span><span class="token punctuation">(</span><span class="token parameter">status</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setIsOnline</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span>isOnline<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  ChatAPI<span class="token punctuation">.</span><span class="token function">subscribeToFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    ChatAPI<span class="token punctuation">.</span><span class="token function">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仅在 props.friend.id 发生变化时，重新订阅</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>**提示：**与 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 不同，使用 <code>useEffect</code> 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 <code>useLayoutEffect</code> Hook 供你使用，其 API 与 <code>useEffect</code> 相同。</p></blockquote><h2 id="_26-react题-usememo与usecallback区别" tabindex="-1"><a class="header-anchor" href="#_26-react题-usememo与usecallback区别" aria-hidden="true">#</a> 26.React题，useMemo与useCallback区别？</h2><p><code>useMemo</code> 和 <code>useCallback</code> 接收的参数都是一样,第一个参数为回调 第二个参数为要依赖的数据</p><p>**共同作用： **1.仅仅 <code>依赖数据</code> 发生变化, 才会重新计算结果，也就是起到缓存的作用。</p><p>**两者区别： **1.<code>useMemo</code> 计算结果是 <code>return</code> 回来的值, 主要用于 缓存计算结果的值 ，应用场景如： 需要 计算的状态 2.<code>useCallback</code> 计算结果是 <code>函数</code>, 主要用于 缓存函数，应用场景如: 需要缓存的函数，因为函数式组件每次任何一个 state 的变化 整个组件 都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能，和减少资源浪费。</p><blockquote><p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p></blockquote><p>注意： 不要滥用会造成性能浪费，react中减少render就能提高性能，所以这个仅仅只针对缓存能减少重复渲染时使用和缓存计算结果。</p><h2 id="_27-顺时针循环打印二维数组" tabindex="-1"><a class="header-anchor" href="#_27-顺时针循环打印二维数组" aria-hidden="true">#</a> 27.顺时针循环打印二维数组</h2><p><em>有一个 n x n 的二维数组，从 [0,0] 元素开始，顺时针循环打印出该数组内容。</em></p><ul><li>输入：const array = [[1,2,3],[4,5,6],[7,8,9]]</li><li>输出：print(array) // 1,2,3,6,9,8,7,4,5</li></ul><p><em>(暂时没有找到比较好的写法 ，大佬还请给个思路。)</em></p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: jingmin.jiang@cloudminds.com">jingmin.jiang</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/posts/experience/eight_001.html" class="" aria-label="八股文-001"><!--[--><!--]--> 八股文-001 <!--[--><!--]--></a></span><span class="next"><a href="/posts/experience/fengchao.html" class="" aria-label="丰巢科技"><!--[--><!--]--> 丰巢科技 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.77cde27d.js" defer></script>
  </body>
</html>
