<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/favicon.ico"><title>Webpack | 前端档案</title><meta name="description" content="前端通关宝典">
    <link rel="modulepreload" href="/assets/app.6e1280c8.js"><link rel="modulepreload" href="/assets/index.html.4551db9a.js"><link rel="modulepreload" href="/assets/index.html.e7f488fa.js">
    <link rel="stylesheet" href="/assets/style.39d5bbe5.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="/logo.png" alt="前端档案"><span class="site-name can-hide">前端档案</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/posts/guide/" class="" aria-label="指南"><!--[--><!--]--> 指南 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/fe/" class="router-link-active" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/be/" class="" aria-label="后端"><!--[--><!--]--> 后端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/base/" class="" aria-label="基础"><!--[--><!--]--> 基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/resume/" class="" aria-label="简历"><!--[--><!--]--> 简历 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/experience/" class="" aria-label="面经"><!--[--><!--]--> 面经 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/tools/" class="" aria-label="工具"><!--[--><!--]--> 工具 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/posts/guide/" class="" aria-label="指南"><!--[--><!--]--> 指南 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/fe/" class="router-link-active" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/be/" class="" aria-label="后端"><!--[--><!--]--> 后端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/base/" class="" aria-label="基础"><!--[--><!--]--> 基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/resume/" class="" aria-label="简历"><!--[--><!--]--> 简历 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/experience/" class="" aria-label="面经"><!--[--><!--]--> 面经 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/posts/tools/" class="" aria-label="工具"><!--[--><!--]--> 工具 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">HTML <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/posts/fe/html/" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">CSS <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/posts/fe/css/" class="sidebar-item" aria-label="目录"><!--[--><!--]--> 目录 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/animation.html" class="sidebar-item" aria-label="css3动画有哪些？"><!--[--><!--]--> css3动画有哪些？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/BFC.html" class="sidebar-item" aria-label="BFC 块级格式化上下文"><!--[--><!--]--> BFC 块级格式化上下文 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/box_model.html" class="sidebar-item" aria-label="盒模型"><!--[--><!--]--> 盒模型 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/center.html" class="sidebar-item" aria-label="元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><!--[--><!--]--> 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/column_layout.html" class="sidebar-item" aria-label="实现两栏布局，右侧自适应？三栏布局中间自适应？"><!--[--><!--]--> 实现两栏布局，右侧自适应？三栏布局中间自适应？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/css.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/css3_features.html" class="sidebar-item" aria-label="CSS3新增了哪些新特性？"><!--[--><!--]--> CSS3新增了哪些新特性？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/css_performance.html" class="sidebar-item" aria-label="如果要做优化，CSS提高性能的方法有哪些？"><!--[--><!--]--> 如果要做优化，CSS提高性能的方法有哪些？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/dp_px_dpr_ppi.html" class="sidebar-item" aria-label="说说设备像素、css像素、设备独立像素、dpr、ppi 之间的区别？"><!--[--><!--]--> 说说设备像素、css像素、设备独立像素、dpr、ppi 之间的区别？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/em_px_rem_vh_vw.html" class="sidebar-item" aria-label="说说em/px/rem/vh/vw区别?"><!--[--><!--]--> 说说em/px/rem/vh/vw区别? <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/flexbox.html" class="sidebar-item" aria-label="Flexbox 弹性布局"><!--[--><!--]--> Flexbox 弹性布局 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/grid.html" class="sidebar-item" aria-label="介绍一下grid网格布局"><!--[--><!--]--> 介绍一下grid网格布局 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/hide_attributes.html" class="sidebar-item" aria-label="css中，有哪些方式可以隐藏页面元素？区别?"><!--[--><!--]--> css中，有哪些方式可以隐藏页面元素？区别? <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/less_12px.html" class="sidebar-item" aria-label="让Chrome支持小于12px 的文字方式有哪些？区别？"><!--[--><!--]--> 让Chrome支持小于12px 的文字方式有哪些？区别？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/reflow_repaint.html" class="sidebar-item" aria-label="回流和重绘"><!--[--><!--]--> 回流和重绘 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/responsive_layout.html" class="sidebar-item" aria-label="什么是响应式设计？响应式设计的基本原理是什么？如何做？"><!--[--><!--]--> 什么是响应式设计？响应式设计的基本原理是什么？如何做？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/sass_less_stylus.html" class="sidebar-item" aria-label="说说对Css预编语言的理解？有哪些区别?"><!--[--><!--]--> 说说对Css预编语言的理解？有哪些区别? <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/selector.html" class="sidebar-item" aria-label="css选择器有哪些？优先级？哪些属性可以继承？"><!--[--><!--]--> css选择器有哪些？优先级？哪些属性可以继承？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/single_multi_line.html" class="sidebar-item" aria-label="如何实现单行／多行文本溢出的省略样式？"><!--[--><!--]--> 如何实现单行／多行文本溢出的省略样式？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/triangle.html" class="sidebar-item" aria-label="CSS如何画一个三角形？原理是什么？"><!--[--><!--]--> CSS如何画一个三角形？原理是什么？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/css/visual_scrolling.html" class="sidebar-item" aria-label="如何使用css完成视差滚动效果?"><!--[--><!--]--> 如何使用css完成视差滚动效果? <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">JavaScript <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/posts/fe/javascript/" class="sidebar-item" aria-label="问题汇总"><!--[--><!--]--> 问题汇总 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/ajax.html" class="sidebar-item" aria-label="Ajax"><!--[--><!--]--> Ajax <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/array.html" class="sidebar-item" aria-label="Array 数组"><!--[--><!--]--> Array 数组 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/bind_call_apply.html" class="sidebar-item" aria-label="bind、call、apply"><!--[--><!--]--> bind、call、apply <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/BOM.html" class="sidebar-item" aria-label="BOM"><!--[--><!--]--> BOM <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/cache.html" class="sidebar-item" aria-label="本地存储"><!--[--><!--]--> 本地存储 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/clone.html" class="sidebar-item" aria-label="深浅拷贝"><!--[--><!--]--> 深浅拷贝 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/closure.html" class="sidebar-item" aria-label="闭包"><!--[--><!--]--> 闭包 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/context_stack.html" class="sidebar-item" aria-label="执行上下文和执行栈"><!--[--><!--]--> 执行上下文和执行栈 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/continue_to_upload.html" class="sidebar-item" aria-label="大文件上传如何做断点续传？"><!--[--><!--]--> 大文件上传如何做断点续传？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/data_type.html" class="sidebar-item" aria-label="数据类型"><!--[--><!--]--> 数据类型 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/debounce_throttle.html" class="sidebar-item" aria-label="防抖和节流"><!--[--><!--]--> 防抖和节流 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/Dom.html" class="sidebar-item" aria-label="DOM常见的操作有哪些？"><!--[--><!--]--> DOM常见的操作有哪些？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/equal.html" class="sidebar-item" aria-label="==和===的区别"><!--[--><!--]--> ==和===的区别 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/event_agent.html" class="sidebar-item" aria-label="事件代理"><!--[--><!--]--> 事件代理 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/event_loop.html" class="sidebar-item" aria-label="事件循环机制"><!--[--><!--]--> 事件循环机制 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/event_Model.html" class="sidebar-item" aria-label="事件模型"><!--[--><!--]--> 事件模型 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/functional_programming.html" class="sidebar-item" aria-label="函数式编程"><!--[--><!--]--> 函数式编程 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/function_cache.html" class="sidebar-item" aria-label="如何实现函数缓存"><!--[--><!--]--> 如何实现函数缓存 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/inherit.html" class="sidebar-item" aria-label="继承"><!--[--><!--]--> 继承 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/js.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/js_bridge.html" class="sidebar-item" aria-label="JSBridge"><!--[--><!--]--> JSBridge <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/js_data_structure.html" class="sidebar-item" aria-label="js数据结构"><!--[--><!--]--> js数据结构 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/loss_accuracy.html" class="sidebar-item" aria-label="Javascript 数字精度丢失问题"><!--[--><!--]--> Javascript 数字精度丢失问题 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/memory_leak.html" class="sidebar-item" aria-label="内存泄漏"><!--[--><!--]--> 内存泄漏 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/new.html" class="sidebar-item" aria-label="new 操作符具体干了什么？"><!--[--><!--]--> new 操作符具体干了什么？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/null_undefined.html" class="sidebar-item" aria-label="undefined 与 null 的区别"><!--[--><!--]--> undefined 与 null 的区别 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/prototype.html" class="sidebar-item" aria-label="原型、原型链"><!--[--><!--]--> 原型、原型链 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/pull_up_loading_pull_down_refresh.html" class="sidebar-item" aria-label="如何实现上拉加载，下拉刷新？"><!--[--><!--]--> 如何实现上拉加载，下拉刷新？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/regexp.html" class="sidebar-item" aria-label="正则表达式"><!--[--><!--]--> 正则表达式 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/scope.html" class="sidebar-item" aria-label="作用域链"><!--[--><!--]--> 作用域链 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/single_sign.html" class="sidebar-item" aria-label="什么是单点登录？如何实现？"><!--[--><!--]--> 什么是单点登录？如何实现？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/string_api.html" class="sidebar-item" aria-label="js 字符串的常用方法"><!--[--><!--]--> js 字符串的常用方法 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/tail_recursion.html" class="sidebar-item" aria-label="举例说明你对尾递归的理解，有哪些应用场景"><!--[--><!--]--> 举例说明你对尾递归的理解，有哪些应用场景 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/this.html" class="sidebar-item" aria-label="This"><!--[--><!--]--> This <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/typeof_instanceof.html" class="sidebar-item" aria-label="typeof 与 instanceof 区别"><!--[--><!--]--> typeof 与 instanceof 区别 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/type_conversion.html" class="sidebar-item" aria-label="类型转换"><!--[--><!--]--> 类型转换 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/javascript/visible.html" class="sidebar-item" aria-label="如何判断一个元素是否在可视区域中？"><!--[--><!--]--> 如何判断一个元素是否在可视区域中？ <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">TypeScript <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/posts/fe/typescript/" class="sidebar-item" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/typescript/ts_react.html" class="sidebar-item" aria-label="在 React 中使用 TypeScript"><!--[--><!--]--> 在 React 中使用 TypeScript <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">ES6 <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/posts/fe/es6/" class="sidebar-item" aria-label="ECMAScript 6+ (ES 2015+)"><!--[--><!--]--> ECMAScript 6+ (ES 2015+) <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/array.html" class="sidebar-item" aria-label="数组的扩展"><!--[--><!--]--> 数组的扩展 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/decorator.html" class="sidebar-item" aria-label="Decorator 装饰器"><!--[--><!--]--> Decorator 装饰器 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/Fetch.html" class="sidebar-item" aria-label="Fetch"><!--[--><!--]--> Fetch <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/function.html" class="sidebar-item" aria-label="函数的扩展"><!--[--><!--]--> 函数的扩展 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/generator.html" class="sidebar-item" aria-label="Generator 函数"><!--[--><!--]--> Generator 函数 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/Iterator.html" class="sidebar-item" aria-label="Iterator接口实现"><!--[--><!--]--> Iterator接口实现 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/let_const_var.html" class="sidebar-item" aria-label="let、const、var"><!--[--><!--]--> let、const、var <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/module.html" class="sidebar-item" aria-label="Module 模块"><!--[--><!--]--> Module 模块 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/object.html" class="sidebar-item" aria-label="对象的扩展"><!--[--><!--]--> 对象的扩展 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/promise.html" class="sidebar-item" aria-label="Promise 对象"><!--[--><!--]--> Promise 对象 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/proxy.html" class="sidebar-item" aria-label="Proxy 代理"><!--[--><!--]--> Proxy 代理 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/require_import.html" class="sidebar-item" aria-label="require 和 import 的区别？"><!--[--><!--]--> require 和 import 的区别？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/set_map.html" class="sidebar-item" aria-label="Set 和 Map 数据结构"><!--[--><!--]--> Set 和 Map 数据结构 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/es6/websocket_ajax.html" class="sidebar-item" aria-label="websocket与ajax的区别浅析"><!--[--><!--]--> websocket与ajax的区别浅析 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">Vue <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/posts/fe/vue/" class="sidebar-item" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/404.html" class="sidebar-item" aria-label="vue项目本地开发完成后部署到服务器后报404是什么原因呢？"><!--[--><!--]--> vue项目本地开发完成后部署到服务器后报404是什么原因呢？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/array_object.html" class="sidebar-item" aria-label="Vue不能检测到Object/Array更新的情况"><!--[--><!--]--> Vue不能检测到Object/Array更新的情况 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/axios.html" class="sidebar-item" aria-label="Vue项目中有封装过axios吗？主要是封装哪方面的？"><!--[--><!--]--> Vue项目中有封装过axios吗？主要是封装哪方面的？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/axios_code.html" class="sidebar-item" aria-label="你了解axios的原理吗？有看过它的源码吗？"><!--[--><!--]--> 你了解axios的原理吗？有看过它的源码吗？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/communication.html" class="sidebar-item" aria-label="Vue组件之间的通信方式都有哪些？"><!--[--><!--]--> Vue组件之间的通信方式都有哪些？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/components_plugin.html" class="sidebar-item" aria-label="Vue中组件和插件有什么区别？"><!--[--><!--]--> Vue中组件和插件有什么区别？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/computed_watch.html" class="sidebar-item" aria-label="计算属性 VS 监听属性"><!--[--><!--]--> 计算属性 VS 监听属性 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/cors.html" class="sidebar-item" aria-label="Vue项目中你是如何解决跨域的呢？"><!--[--><!--]--> Vue项目中你是如何解决跨域的呢？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/data.html" class="sidebar-item" aria-label="为什么data属性是一个函数而不是一个对象？"><!--[--><!--]--> 为什么data属性是一个函数而不是一个对象？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/data_object_add_attrs.html" class="sidebar-item" aria-label="动态给vue的data添加一个新的属性时会发生什么？怎样解决？"><!--[--><!--]--> 动态给vue的data添加一个新的属性时会发生什么？怎样解决？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/diff.html" class="sidebar-item" aria-label="Diff 算法"><!--[--><!--]--> Diff 算法 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/directive.html" class="sidebar-item" aria-label="自定义指令"><!--[--><!--]--> 自定义指令 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/error.html" class="sidebar-item" aria-label="你是怎么处理vue项目中的错误的？"><!--[--><!--]--> 你是怎么处理vue项目中的错误的？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/EventBus.html" class="sidebar-item" aria-label="事件总线 EventBus"><!--[--><!--]--> 事件总线 EventBus <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/filter.html" class="sidebar-item" aria-label="Vue中的过滤器了解吗？过滤器的应用场景有哪些？"><!--[--><!--]--> Vue中的过滤器了解吗？过滤器的应用场景有哪些？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/first_page_time.html" class="sidebar-item" aria-label="SPA首屏加载速度慢的怎么解决？"><!--[--><!--]--> SPA首屏加载速度慢的怎么解决？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/if_for.html" class="sidebar-item" aria-label="v-if和v-for的优先级是什么？"><!--[--><!--]--> v-if和v-for的优先级是什么？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/if_show.html" class="sidebar-item" aria-label="v-show 和 v-if 有什么区别？"><!--[--><!--]--> v-show 和 v-if 有什么区别？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/keepalive.html" class="sidebar-item" aria-label="说说你对keep-alive的理解是什么？"><!--[--><!--]--> 说说你对keep-alive的理解是什么？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/key.html" class="sidebar-item" aria-label="Key的理解"><!--[--><!--]--> Key的理解 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/lazyload.html" class="sidebar-item" aria-label="Vue项目中实现图片懒加载"><!--[--><!--]--> Vue项目中实现图片懒加载 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/lifecycle.html" class="sidebar-item" aria-label="Vue 生命周期的理解"><!--[--><!--]--> Vue 生命周期的理解 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/mixin.html" class="sidebar-item" aria-label="Mixin 混入"><!--[--><!--]--> Mixin 混入 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/modifier.html" class="sidebar-item" aria-label="Vue常用的修饰符有哪些有什么应用场景"><!--[--><!--]--> Vue常用的修饰符有哪些有什么应用场景 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/mvvm.html" class="sidebar-item" aria-label="MVVM 双向数据绑定"><!--[--><!--]--> MVVM 双向数据绑定 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/new_vue.html" class="sidebar-item" aria-label="Vue实例挂载的过程"><!--[--><!--]--> Vue实例挂载的过程 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/nexttick.html" class="sidebar-item" aria-label="Vue中的$nextTick有什么作用？"><!--[--><!--]--> Vue中的$nextTick有什么作用？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/observable.html" class="sidebar-item" aria-label="Vue.observable你有了解过吗？说说看"><!--[--><!--]--> Vue.observable你有了解过吗？说说看 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/permission.html" class="sidebar-item" aria-label="vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？"><!--[--><!--]--> vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/slot.html" class="sidebar-item" aria-label="说说你对slot的理解？slot使用场景有哪些？"><!--[--><!--]--> 说说你对slot的理解？slot使用场景有哪些？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/spa.html" class="sidebar-item" aria-label="你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"><!--[--><!--]--> 你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/ssr.html" class="sidebar-item" aria-label="SSR解决了什么问题？有做过SSR吗？你是怎么做的？"><!--[--><!--]--> SSR解决了什么问题？有做过SSR吗？你是怎么做的？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/structure.html" class="sidebar-item" aria-label="说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？"><!--[--><!--]--> 说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/vnode.html" class="sidebar-item" aria-label="虚拟DOM"><!--[--><!--]--> 虚拟DOM <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/vue-debounce-throttle.html" class="sidebar-item" aria-label="vue防抖调研"><!--[--><!--]--> vue防抖调研 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/vuex.html" class="sidebar-item" aria-label="Vuex"><!--[--><!--]--> Vuex <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/vue_react.html" class="sidebar-item" aria-label="Vue 和 React 区别"><!--[--><!--]--> Vue 和 React 区别 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue/vue_router.html" class="sidebar-item" aria-label="Vue Router"><!--[--><!--]--> Vue Router <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">Vue3 <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/posts/fe/vue3/" class="sidebar-item" aria-label="Vue 3"><!--[--><!--]--> Vue 3 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue3/composition.html" class="sidebar-item" aria-label="Composition Api"><!--[--><!--]--> Composition Api <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue3/modal_component.html" class="sidebar-item" aria-label="Vue3 实现 Modal 组件"><!--[--><!--]--> Vue3 实现 Modal 组件 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue3/performance.html" class="sidebar-item" aria-label="Vue3.0 性能提升"><!--[--><!--]--> Vue3.0 性能提升 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue3/proxy.html" class="sidebar-item" aria-label="Proxy 替代 defineProperty"><!--[--><!--]--> Proxy 替代 defineProperty <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue3/tree_shaking.html" class="sidebar-item" aria-label="tree shaking"><!--[--><!--]--> tree shaking <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/vue3/vue3_vue2.html" class="sidebar-item" aria-label="vue3 与 vue2 区别"><!--[--><!--]--> vue3 与 vue2 区别 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">React <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/posts/fe/react/" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/animation.html" class="sidebar-item" aria-label="react中组件间过渡动画"><!--[--><!--]--> react中组件间过渡动画 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/class_function.html" class="sidebar-item" aria-label="类组件与函数组件"><!--[--><!--]--> 类组件与函数组件 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/communication.html" class="sidebar-item" aria-label="Reat组件间通信"><!--[--><!--]--> Reat组件间通信 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/component.html" class="sidebar-item" aria-label="React构建组件的方式"><!--[--><!--]--> React构建组件的方式 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/controlled_uncontrolled.html" class="sidebar-item" aria-label="受控组件和非受控组件"><!--[--><!--]--> 受控组件和非受控组件 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/diff.html" class="sidebar-item" aria-label="React diff"><!--[--><!--]--> React diff <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/dva.html" class="sidebar-item" aria-label="DvaJS"><!--[--><!--]--> DvaJS <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/error.html" class="sidebar-item" aria-label="React 捕获错误"><!--[--><!--]--> React 捕获错误 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/event_binding.html" class="sidebar-item" aria-label="React 事件绑定"><!--[--><!--]--> React 事件绑定 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/fiber.html" class="sidebar-item" aria-label="React Fiber 架构"><!--[--><!--]--> React Fiber 架构 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/higher_order_function.html" class="sidebar-item" aria-label="高阶组件"><!--[--><!--]--> 高阶组件 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/hooks.html" class="sidebar-item" aria-label="React Hooks"><!--[--><!--]--> React Hooks <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/immutable.html" class="sidebar-item" aria-label="Immutable 对象"><!--[--><!--]--> Immutable 对象 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/import_css.html" class="sidebar-item" aria-label="react引入css的方式"><!--[--><!--]--> react引入css的方式 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/improve_render.html" class="sidebar-item" aria-label="提高组件的render渲染效率"><!--[--><!--]--> 提高组件的render渲染效率 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/jsx.html" class="sidebar-item" aria-label="JSX"><!--[--><!--]--> JSX <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/jsx_to_dom.html" class="sidebar-item" aria-label="React Jsx转换成真实DOM过程"><!--[--><!--]--> React Jsx转换成真实DOM过程 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/key.html" class="sidebar-item" aria-label="React中的key"><!--[--><!--]--> React中的key <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/lifecycle.html" class="sidebar-item" aria-label="React 生命周期"><!--[--><!--]--> React 生命周期 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/performance.html" class="sidebar-item" aria-label="React 性能优化"><!--[--><!--]--> React 性能优化 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/react-router.html" class="sidebar-item" aria-label="React Router"><!--[--><!--]--> React Router <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/react_18.html" class="sidebar-item" aria-label="React 18"><!--[--><!--]--> React 18 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/react_api.html" class="sidebar-item" aria-label="React API"><!--[--><!--]--> React API <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/react_sgg.html" class="sidebar-item" aria-label="React - sgg"><!--[--><!--]--> React - sgg <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/redux.html" class="sidebar-item" aria-label="Redux 状态管理库"><!--[--><!--]--> Redux 状态管理库 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/redux_middleware.html" class="sidebar-item" aria-label="Redux 中间件"><!--[--><!--]--> Redux 中间件 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/redux_mobx.html" class="sidebar-item" aria-label="Redux VS MobX"><!--[--><!--]--> Redux VS MobX <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/redux_use.html" class="sidebar-item" aria-label="React 使用 Redux"><!--[--><!--]--> React 使用 Redux <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/refs.html" class="sidebar-item" aria-label="React refs"><!--[--><!--]--> React refs <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/render.html" class="sidebar-item" aria-label="React render"><!--[--><!--]--> React render <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/router.html" class="sidebar-item" aria-label="React Router"><!--[--><!--]--> React Router <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/router_model.html" class="sidebar-item" aria-label="React Router"><!--[--><!--]--> React Router <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/setState.html" class="sidebar-item" aria-label="React setState执行机制"><!--[--><!--]--> React setState执行机制 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/ssr.html" class="sidebar-item" aria-label="React服务端渲染SSR"><!--[--><!--]--> React服务端渲染SSR <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/state_props.html" class="sidebar-item" aria-label="React state 和 props"><!--[--><!--]--> React state 和 props <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/summary.html" class="sidebar-item" aria-label="React 常见问题"><!--[--><!--]--> React 常见问题 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/super()_super(props).html" class="sidebar-item" aria-label="Class super()和super(props)"><!--[--><!--]--> Class super()和super(props) <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/synthetic_event.html" class="sidebar-item" aria-label="React的事件机制"><!--[--><!--]--> React的事件机制 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/react/virtual_dom.html" class="sidebar-item" aria-label="Real DOM 和 Virtual DOM"><!--[--><!--]--> Real DOM 和 Virtual DOM <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">Webpack <span class="down arrow"></span></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/posts/fe/webpack/" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/posts/fe/webpack/#_1-webpack" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. Webpack"><!--[--><!--]--> 1. Webpack <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/posts/fe/webpack/#_1-1-webpack配置entry有几个" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 webpack配置entry有几个"><!--[--><!--]--> 1.1 webpack配置entry有几个 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_1-2-webpack的构建流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 webpack的构建流程"><!--[--><!--]--> 1.2 webpack的构建流程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_1-3-webpack和rollup有什么相同和不同点" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 webpack和rollup有什么相同和不同点？"><!--[--><!--]--> 1.3 webpack和rollup有什么相同和不同点？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_1-4-介绍一下loader" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.4 介绍一下Loader"><!--[--><!--]--> 1.4 介绍一下Loader <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_1-5-介绍一下plugin" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.5 介绍一下Plugin"><!--[--><!--]--> 1.5 介绍一下Plugin <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_1-6-webpack-热更新是如何实现的" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.6 webpack 热更新是如何实现的？"><!--[--><!--]--> 1.6 webpack 热更新是如何实现的？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_1-7-webpack-层面如何做性能优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.7 webpack 层面如何做性能优化"><!--[--><!--]--> 1.7 webpack 层面如何做性能优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_1-8-介绍一下-webpack-的-dll" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.8 介绍一下 webpack 的 dll"><!--[--><!--]--> 1.8 介绍一下 webpack 的 dll <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_1-9-介绍一下-webpack-的-tree-shaking" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.9 介绍一下 webpack 的 tree-shaking"><!--[--><!--]--> 1.9 介绍一下 webpack 的 tree-shaking <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/posts/fe/webpack/#一、背景" class="router-link-active router-link-exact-active sidebar-item" aria-label="一、背景"><!--[--><!--]--> 一、背景 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/posts/fe/webpack/#模块化" class="router-link-active router-link-exact-active sidebar-item" aria-label="模块化"><!--[--><!--]--> 模块化 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/posts/fe/webpack/#二、问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="二、问题"><!--[--><!--]--> 二、问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#三、是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="三、是什么"><!--[--><!--]--> 三、是什么 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#四、webpack的能力" class="router-link-active router-link-exact-active sidebar-item" aria-label="四、Webpack的能力"><!--[--><!--]--> 四、Webpack的能力 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#五、webpack的打包原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="五、webpack的打包原理"><!--[--><!--]--> 五、webpack的打包原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#六、其他相关问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="六、其他相关问题"><!--[--><!--]--> 六、其他相关问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#问题列表webpack与grunt、gulp的不同-与webpack类似的工具还有哪些-谈谈你为什么最终选择-或放弃-使用webpack-有哪些常见的loader-他们是解决什么问题的-有哪些常见的plugin-他们是解决什么问题的-loader和plugin的不同-webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全是否写过loader和plugin-描述一下编写loader或plugin的思路-webpack的热更新是如何做到的-说明其原理-如何利用webpack来优化前端性能-提高性能和体验-如何提高webpack的构建速度-怎么配置单页应用-怎么配置多页应用-npm打包时需要注意哪些-如何利用webpack来更好的构建-如何在vue项目中实现按需加载" class="router-link-active router-link-exact-active sidebar-item" aria-label="问题列表webpack与grunt、gulp的不同？与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？有哪些常见的Loader？他们是解决什么问题的？有哪些常见的Plugin？他们是解决什么问题的？Loader和Plugin的不同？webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全是否写过Loader和Plugin？描述一下编写loader或plugin的思路？webpack的热更新是如何做到的？说明其原理？如何利用webpack来优化前端性能？（提高性能和体验）如何提高webpack的构建速度？怎么配置单页应用？怎么配置多页应用？npm打包时需要注意哪些？如何利用webpack来更好的构建？如何在vue项目中实现按需加载？"><!--[--><!--]--> 问题列表webpack与grunt、gulp的不同？与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？有哪些常见的Loader？他们是解决什么问题的？有哪些常见的Plugin？他们是解决什么问题的？Loader和Plugin的不同？webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全是否写过Loader和Plugin？描述一下编写loader或plugin的思路？webpack的热更新是如何做到的？说明其原理？如何利用webpack来优化前端性能？（提高性能和体验）如何提高webpack的构建速度？怎么配置单页应用？怎么配置多页应用？npm打包时需要注意哪些？如何利用webpack来更好的构建？如何在vue项目中实现按需加载？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_3-有哪些常见的loader-他们是解决什么问题的-file-loader-把文件输出到一个文件夹中-在代码中通过相对-url-去引用输出的文件url-loader-和-file-loader-类似-但是能在文件很小的情况下以-base64-的方式把文件内容注入到代码中去source-map-loader-加载额外的-source-map-文件-以方便断点调试image-loader-加载并且压缩图片文件babel-loader-把-es6-转换成-es5css-loader-加载-css-支持模块化、压缩、文件导入等特性style-loader-把-css-代码注入到-javascript-中-通过-dom-操作去加载-css。eslint-loader-通过-eslint-检查-javascript-代码" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.有哪些常见的Loader？他们是解决什么问题的？file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去source-map-loader：加载额外的 Source Map 文件，以方便断点调试image-loader：加载并且压缩图片文件babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。eslint-loader：通过 ESLint 检查 JavaScript 代码"><!--[--><!--]--> 3.有哪些常见的Loader？他们是解决什么问题的？file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去source-map-loader：加载额外的 Source Map 文件，以方便断点调试image-loader：加载并且压缩图片文件babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。eslint-loader：通过 ESLint 检查 JavaScript 代码 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_4-有哪些常见的plugin-他们是解决什么问题的-define-plugin-定义环境变量commons-chunk-plugin-提取公共代码uglifyjs-webpack-plugin-通过uglifyes压缩es6代码" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.有哪些常见的Plugin？他们是解决什么问题的？define-plugin：定义环境变量commons-chunk-plugin：提取公共代码uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码"><!--[--><!--]--> 4.有哪些常见的Plugin？他们是解决什么问题的？define-plugin：定义环境变量commons-chunk-plugin：提取公共代码uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_5-loader和plugin的不同-不同的作用loader直译为-加载器-。webpack将一切文件视为模块-但是webpack原生是只能解析js文件-如果想将其他文件也打包的话-就会用到loader。-所以loader的作用是让webpack拥有了加载和解析非javascript文件的能力。plugin直译为-插件-。plugin可以扩展webpack的功能-让webpack具有更多的灵活性。-在-webpack-运行的生命周期中会广播出许多事件-plugin-可以监听这些事件-在合适的时机通过-webpack-提供的-api-改变输出结果。不同的用法loader在module-rules中配置-也就是说他作为模块的解析规则而存在。-类型为数组-每一项都是一个object-里面描述了对于什么类型的文件-test-使用什么加载-loader-和使用的参数-options-plugin在plugins中单独配置。-类型为数组-每一项是一个plugin的实例-参数都通过构造函数传入。" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.Loader和Plugin的不同？不同的作用Loader直译为&quot;加载器&quot;。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。Plugin直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。不同的用法Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。"><!--[--><!--]--> 5.Loader和Plugin的不同？不同的作用Loader直译为&quot;加载器&quot;。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。Plugin直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。不同的用法Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#webpack-的运行流程是一个串行的过程-从启动到结束会依次执行以下流程初始化参数-从配置文件和-shell-语句中读取与合并参数-得出最终的参数-开始编译-用上一步得到的参数初始化-compiler-对象-加载所有配置的插件-执行对象的-run-方法开始执行编译-确定入口-根据配置中的-entry-找出所有的入口文件-编译模块-从入口文件出发-调用所有配置的-loader-对模块进行翻译-再找出该模块依赖的模块-再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理-完成模块编译-在经过第4步使用-loader-翻译完所有模块后-得到了每个模块被翻译后的最终内容以及它们之间的依赖关系-输出资源-根据入口和模块之间的依赖关系-组装成一个个包含多个模块的-chunk-再把每个-chunk-转换成一个单独的文件加入到输出列表-这步是可以修改输出内容的最后机会-输出完成-在确定好输出内容后-根据配置确定输出的路径和文件名-把文件内容写入到文件系统。在以上过程中-webpack-会在特定的时间点广播出特定的事件-插件在监听到感兴趣的事件后会执行特定的逻辑-并且插件可以调用-webpack-提供的-api-改变-webpack-的运行结果。" class="router-link-active router-link-exact-active sidebar-item" aria-label="Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；确定入口：根据配置中的 entry 找出所有的入口文件；编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。"><!--[--><!--]--> Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；确定入口：根据配置中的 entry 找出所有的入口文件；编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_7-是否写过loader和plugin-描述一下编写loader或plugin的思路-loader像一个-翻译官-把读到的源文件内容转义成新的文件内容-并且每个loader通过链式操作-将源文件一步步翻译成想要的样子。编写loader时要遵循单一原则-每个loader只做一种-转义-工作。-每个loader的拿到的是源文件内容-source-可以通过返回值的方式将处理后的内容输出-也可以调用this-callback-方法-将内容返回给webpack。-还可以通过-this-async-生成一个callback函数-再用这个callback将处理后的内容输出出去。-此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。相对于loader而言-plugin的编写就灵活了许多。-webpack在运行的生命周期中会广播出许多事件-plugin-可以监听这些事件-在合适的时机通过-webpack-提供的-api-改变输出结果。" class="router-link-active router-link-exact-active sidebar-item" aria-label="7.是否写过Loader和Plugin？描述一下编写loader或plugin的思路？Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。"><!--[--><!--]--> 7.是否写过Loader和Plugin？描述一下编写loader或plugin的思路？Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#最后一步-当-hmr-失败后-回退到-live-reload-操作-也就是进行浏览器刷新来获取最新打包代码" class="router-link-active router-link-exact-active sidebar-item" aria-label="最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码"><!--[--><!--]--> 最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_9-如何利用webpack来优化前端性能-提高性能和体验-用webpack优化前端性能是指优化webpack的输出结果-让打包的最终结果在浏览器运行快速高效。压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的uglifyjsplugin和paralleluglifyplugin来压缩js文件-利用cssnano-css-loader-minimize-来压缩css利用cdn加速。在构建过程中-将引用的静态资源路径修改为cdn上对应的路径。可以利用webpack对于output参数和各loader的publicpath参数来修改资源路径删除死代码-tree-shaking-。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数-optimize-minimize来实现提取公共代码。" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.如何利用webpack来优化前端性能？（提高性能和体验）用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现提取公共代码。"><!--[--><!--]--> 9.如何利用webpack来优化前端性能？（提高性能和体验）用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现提取公共代码。 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_10-如何提高webpack的构建速度-多入口情况下-使用commonschunkplugin来提取公共代码通过externals配置来提取常用库利用dllplugin和dllreferenceplugin预编译资源模块-通过dllplugin来对那些我们引用但是绝对不会修改的npm包来进行预编译-再通过dllreferenceplugin将预编译的模块加载进来。使用happypack-实现多线程加速编译使用webpack-uglify-parallel来提升uglifyplugin的压缩速度。-原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度使用tree-shaking和scope-hoisting来剔除多余代码" class="router-link-active router-link-exact-active sidebar-item" aria-label="10.如何提高webpack的构建速度？多入口情况下，使用CommonsChunkPlugin来提取公共代码通过externals配置来提取常用库利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。使用Happypack 实现多线程加速编译使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度使用Tree-shaking和Scope Hoisting来剔除多余代码"><!--[--><!--]--> 10.如何提高webpack的构建速度？多入口情况下，使用CommonsChunkPlugin来提取公共代码通过externals配置来提取常用库利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。使用Happypack 实现多线程加速编译使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度使用Tree-shaking和Scope Hoisting来剔除多余代码 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/posts/fe/webpack/#_11-怎么配置单页应用-怎么配置多页应用-单页应用可以理解为webpack的标准模式-直接在entry中指定单页应用的入口即可-这里不再赘述多页应用的话-可以使用webpack的-autowebplugin来完成简单自动化的构建-但是前提是项目的目录结构必须遵守他预设的规范。-多页应用中要注意的是-每个页面都有公共的代码-可以将这些代码抽离出来-避免重复的加载。比如-每个页面都引用了同一套css样式表随着业务的不断扩展-页面可能会不断的追加-所以一定要让入口的配置足够灵活-避免每次添加新页面还需要修改构建配置" class="router-link-active router-link-exact-active sidebar-item" aria-label="11.怎么配置单页应用？怎么配置多页应用？单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是：每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置"><!--[--><!--]--> 11.怎么配置单页应用？怎么配置多页应用？单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是：每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/posts/fe/webpack/babel.html" class="sidebar-item" aria-label="Babel"><!--[--><!--]--> Babel <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/webpack/build_process.html" class="sidebar-item" aria-label="说说webpack的构建流程?"><!--[--><!--]--> 说说webpack的构建流程? <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/webpack/HMR.html" class="sidebar-item" aria-label="说说webpack的热更新是如何做到的？原理是什么？"><!--[--><!--]--> 说说webpack的热更新是如何做到的？原理是什么？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/webpack/improve_build.html" class="sidebar-item" aria-label="如何提高webpack的构建速度？"><!--[--><!--]--> 如何提高webpack的构建速度？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/webpack/Loader.html" class="sidebar-item" aria-label="Loader"><!--[--><!--]--> Loader <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/webpack/Loader_Plugin.html" class="sidebar-item" aria-label="Loader和Plugin的区别？编写Loader，Plugin的思路？"><!--[--><!--]--> Loader和Plugin的区别？编写Loader，Plugin的思路？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/webpack/performance.html" class="sidebar-item" aria-label="Webpack 性能优化"><!--[--><!--]--> Webpack 性能优化 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/webpack/Plugin.html" class="sidebar-item" aria-label="Plugin"><!--[--><!--]--> Plugin <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/webpack/proxy.html" class="sidebar-item" aria-label="说说webpack proxy工作原理？为什么能解决跨域?"><!--[--><!--]--> 说说webpack proxy工作原理？为什么能解决跨域? <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/webpack/publish.html" class="sidebar-item" aria-label="前端发布"><!--[--><!--]--> 前端发布 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/webpack/Rollup_Parcel_snowpack_Vite.html" class="sidebar-item" aria-label="与webpack类似的工具还有哪些？区别？"><!--[--><!--]--> 与webpack类似的工具还有哪些？区别？ <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">Node.js <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/posts/fe/nodejs/" class="sidebar-item" aria-label="说说你对Node.js 的理解？优缺点？应用场景？"><!--[--><!--]--> 说说你对Node.js 的理解？优缺点？应用场景？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/nodejs/buffer.html" class="sidebar-item" aria-label="说说对 Node 中的 Buffer 的理解？应用场景？"><!--[--><!--]--> 说说对 Node 中的 Buffer 的理解？应用场景？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/nodejs/event_emitter.html" class="sidebar-item" aria-label="说说Node中的EventEmitter? 如何实现一个EventEmitter?"><!--[--><!--]--> 说说Node中的EventEmitter? 如何实现一个EventEmitter? <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/nodejs/event_loop.html" class="sidebar-item" aria-label="说说对Nodejs中的事件循环机制理解?"><!--[--><!--]--> 说说对Nodejs中的事件循环机制理解? <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/nodejs/file_upload.html" class="sidebar-item" aria-label="如何实现文件上传？说说你的思路"><!--[--><!--]--> 如何实现文件上传？说说你的思路 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/nodejs/fs.html" class="sidebar-item" aria-label="说说对 Node 中的 fs模块的理解? 有哪些常用方法"><!--[--><!--]--> 说说对 Node 中的 fs模块的理解? 有哪些常用方法 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/nodejs/global.html" class="sidebar-item" aria-label="说说 Node. js 有哪些全局对象？"><!--[--><!--]--> 说说 Node. js 有哪些全局对象？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/nodejs/jwt.html" class="sidebar-item" aria-label="如何实现jwt鉴权机制？说说你的思路"><!--[--><!--]--> 如何实现jwt鉴权机制？说说你的思路 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/nodejs/middleware.html" class="sidebar-item" aria-label="说说对中间件概念的理解，如何封装 node 中间件？"><!--[--><!--]--> 说说对中间件概念的理解，如何封装 node 中间件？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/nodejs/paging.html" class="sidebar-item" aria-label="如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?"><!--[--><!--]--> 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互? <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/nodejs/performance.html" class="sidebar-item" aria-label="Node性能如何进行监控以及优化？"><!--[--><!--]--> Node性能如何进行监控以及优化？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/nodejs/process.html" class="sidebar-item" aria-label="说说对 Node 中的 process 的理解？有哪些常用方法？"><!--[--><!--]--> 说说对 Node 中的 process 的理解？有哪些常用方法？ <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/nodejs/require_order.html" class="sidebar-item" aria-label="说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?"><!--[--><!--]--> 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略? <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/nodejs/stream.html" class="sidebar-item" aria-label="说说对 Node 中的 Stream 的理解？应用场景？"><!--[--><!--]--> 说说对 Node 中的 Stream 的理解？应用场景？ <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">性能优化 <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/posts/fe/performance/" class="sidebar-item" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">手写代码 <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/posts/fe/handwritten/" class="sidebar-item" aria-label="常见JS代码实现"><!--[--><!--]--> 常见JS代码实现 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/handwritten/code.html" class="sidebar-item" aria-label="常见编程题"><!--[--><!--]--> 常见编程题 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/handwritten/concurrent.html" class="sidebar-item" aria-label="前端并发请求控制，一次最多并发3个"><!--[--><!--]--> 前端并发请求控制，一次最多并发3个 <!--[--><!--]--></a><!----></li><li><a href="/posts/fe/handwritten/promise.html" class="sidebar-item" aria-label="Promise"><!--[--><!--]--> Promise <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="webpack" tabindex="-1"><a class="header-anchor" href="#webpack" aria-hidden="true">#</a> Webpack</h1><ul><li><p><a href="https://webpack.docschina.org/concepts/" target="_blank" rel="noopener noreferrer">Webpack 中文文档<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/363928061" target="_blank" rel="noopener noreferrer">[万字总结] 一文吃透 Webpack 核心原理 - 知乎<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://juejin.cn/post/6844903966849892359" target="_blank" rel="noopener noreferrer">从 0 到 1 实现一款简易版 Webpack<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://juejin.cn/post/6844904023791796237" target="_blank" rel="noopener noreferrer">Webpack 设置环境变量的误区<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p>说说Webpack的实现原理</p></li><li><p>对webpack的理解？解决了什么问题？</p></li></ul><h2 id="_1-webpack" tabindex="-1"><a class="header-anchor" href="#_1-webpack" aria-hidden="true">#</a> 1. Webpack</h2><ul><li><a href="https://juejin.im/post/6844903588607557639" target="_blank" rel="noopener noreferrer">带你走进webpack世界，成为webpack头号玩家。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://juejin.im/post/6844903853905674248" target="_blank" rel="noopener noreferrer">关于webpack4的14个知识点,童叟无欺<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><p>可以看做一个模块化打包机，分析项目结构，处理模块化依赖，转换成为浏览器可运行的代码。</p><p>webpack作用：</p><ul><li>代码转换: TypeScript 编译成 JavaScript、SCSS,LESS 编译成 CSS.</li><li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片。</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li><li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li></ul><p>构建把一系列前端代码自动化去处理复杂的流程，解放生产力。</p><h3 id="_1-1-webpack配置entry有几个" tabindex="-1"><a class="header-anchor" href="#_1-1-webpack配置entry有几个" aria-hidden="true">#</a> 1.1 webpack配置entry有几个</h3><h3 id="_1-2-webpack的构建流程" tabindex="-1"><a class="header-anchor" href="#_1-2-webpack的构建流程" aria-hidden="true">#</a> 1.2 webpack的构建流程</h3><p>webpack的构建流程包括compile、make、build、seal、emit阶段。</p><p>（1）初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； （2）开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，通过执行对象的 run 方法开始执行编译； （3）确定入口：根据配置中的 entry 找出所有入口文件； （4）编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理； （5）完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容及它们之间的依赖关系； （6）输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再将每个 Chunk 转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会； （7）输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中； 在以上过程中，Webpack 会在特定的时间点广播特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果；</p><h3 id="_1-3-webpack和rollup有什么相同和不同点" tabindex="-1"><a class="header-anchor" href="#_1-3-webpack和rollup有什么相同和不同点" aria-hidden="true">#</a> 1.3 webpack和rollup有什么相同和不同点？</h3><h3 id="_1-4-介绍一下loader" tabindex="-1"><a class="header-anchor" href="#_1-4-介绍一下loader" aria-hidden="true">#</a> 1.4 介绍一下Loader</h3><p><a href="https://github.com/axuebin/articles/issues/38" target="_blank" rel="noopener noreferrer">前端工程师都得掌握的 webpack Loader<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> Loader 的作用很简单，就是处理任意类型的文件，并且将它们转换成一个让 webpack 可以处理的有效模块。</p><p>常用的Loader有：js-<code>babel-loader</code>、css-<code>style-loader``css-loader</code>、``</p><p>Loader 可以在 webpack.config.js 里配置，也可以在 require 语句里内联；</p><h4 id="_1-4-1-在config里配置" tabindex="-1"><a class="header-anchor" href="#_1-4-1-在config里配置" aria-hidden="true">#</a> 1.4.1 在config里配置</h4><p>Loader 可以在 webpack.config.js里配置，这也是推荐的做法，定义在 module.rules 里。</p><p>每一条 rule 会包含两个属性：test 和 use，比如 { test: /.js$/, use: &#39;babel-loader&#39; } 意思就是：当 webpack 遇到扩展名为 js 的文件时，先用 babel-loader 处理一下，然后再打包它。</p><h4 id="_1-4-2-loader-类型" tabindex="-1"><a class="header-anchor" href="#_1-4-2-loader-类型" aria-hidden="true">#</a> 1.4.2 Loader 类型</h4><ol><li>同步Loader：this.callback()</li><li>异步Loader：this.async()</li><li>Pitching Loader：</li><li>Raw Loader：</li></ol><h3 id="_1-5-介绍一下plugin" tabindex="-1"><a class="header-anchor" href="#_1-5-介绍一下plugin" aria-hidden="true">#</a> 1.5 介绍一下Plugin</h3><p>通过插件，扩展 webpack，加入自定义的构建行为，使 webpack 可以执行更广泛的任务，拥有更强的构建能力。</p><h3 id="_1-6-webpack-热更新是如何实现的" tabindex="-1"><a class="header-anchor" href="#_1-6-webpack-热更新是如何实现的" aria-hidden="true">#</a> 1.6 webpack 热更新是如何实现的？</h3><p><a href="https://juejin.im/post/6844904008432222215" target="_blank" rel="noopener noreferrer">轻松理解webpack热更新原理<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>Hot Module Replacement，简称HMR，无需完全刷新整个页面的同时，更新模块。HMR的好处，在日常开发工作中体会颇深：节省宝贵的开发时间、提升开发体验。</p><ol><li>webpack-dev-server启动本地服务：我们根据webpack-dev-server的package.json中的bin命令，可以找到命令的入口文件bin/webpack-dev-server.js。</li><li>修改webpack.config.js的entry配置</li><li>监听webpack编译结束</li><li>webpack监听文件变化</li><li>浏览器接收到热更新的通知</li><li>HotModuleReplacementPlugin 或 --hot</li><li>moudle.hot.check 开始热更新</li><li>hotApply 热更新模块替换 <ul><li>删除过期的模块，就是需要替换的模块</li><li>将新的模块添加到 modules 中</li><li>通过__webpack_require__执行相关模块的代码</li></ul></li></ol><h3 id="_1-7-webpack-层面如何做性能优化" tabindex="-1"><a class="header-anchor" href="#_1-7-webpack-层面如何做性能优化" aria-hidden="true">#</a> 1.7 webpack 层面如何做性能优化</h3><h3 id="_1-8-介绍一下-webpack-的-dll" tabindex="-1"><a class="header-anchor" href="#_1-8-介绍一下-webpack-的-dll" aria-hidden="true">#</a> 1.8 介绍一下 webpack 的 dll</h3><p>DLL动态链接</p><p>第三库不是经常更新，打包的时候希望分开打包，来提升打包速度。打包dll需要新建一个webpack配置文件，在打包dll的时候，webpack做一个索引，写在manifest文件中。然后打包项目文件时只需要读取manifest文件。</p><h3 id="_1-9-介绍一下-webpack-的-tree-shaking" tabindex="-1"><a class="header-anchor" href="#_1-9-介绍一下-webpack-的-tree-shaking" aria-hidden="true">#</a> 1.9 介绍一下 webpack 的 tree-shaking</h3><p>webpack 4 只需要配置mode为 <code>production</code>即可</p><h2 id="一、背景" tabindex="-1"><a class="header-anchor" href="#一、背景" aria-hidden="true">#</a> 一、背景</h2><p><code>Webpack</code> 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源</p><h3 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化" aria-hidden="true">#</a> 模块化</h3><p>最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的<code>JS</code> 文件中</p><p>约定每个文件是一个独立的模块，然后再将这些<code>js</code>文件引入到页面，一个<code>script</code>标签对应一个模块，然后调用模块化的成员</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module-a.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module-b.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题</p><p>项目一旦变大，上述问题会尤其明显</p><p>随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>window<span class="token punctuation">.</span>moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">method1</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;moduleA#method1&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这种方式也并没有解决第一种方式的依赖等问题</p><p>再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// module-a.js</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">$</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&#39;module-a&#39;</span>

  <span class="token keyword">function</span> <span class="token function">method1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">&#39;#method1&#39;</span><span class="token punctuation">)</span>
    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&#39;body&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">margin</span><span class="token operator">:</span> <span class="token string">&#39;200px&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  window<span class="token punctuation">.</span>moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">method1</span><span class="token operator">:</span> method1
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>jQuery<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过<code>script</code>标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦</p><p>理想的解决方式是，在页面中引入一个<code>JS</code>入口文件，其余用到的模块可以通过代码控制，按需加载进来</p><p>除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是<code>CommonJS</code>、<code>ES Modules</code></p><h2 id="二、问题" tabindex="-1"><a class="header-anchor" href="#二、问题" aria-hidden="true">#</a> 二、问题</h2><p>从后端渲染的<code>JSP</code>、<code>PHP</code>，到前端原生<code>JavaScript</code>，再到<code>jQuery</code>开发，再到目前的三大框架<code>Vue</code>、<code>React</code>、<code>Angular</code></p><p>开发方式，也从<code>javascript</code>到后面的<code>es5</code>、<code>es6、7、8、9、10</code>，再到<code>typescript</code>，包括编写<code>CSS</code>的预处理器<code>less</code>、<code>scss</code>等</p><p>现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：</p><ul><li>需要通过模块化的方式来开发</li><li>使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码</li><li>监听文件的变化来并且反映到浏览器上，提高开发的效率</li><li>JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题</li><li>开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化</li></ul><p>而<code>webpack</code>恰巧可以解决以上问题</p><h2 id="三、是什么" tabindex="-1"><a class="header-anchor" href="#三、是什么" aria-hidden="true">#</a> 三、是什么</h2><p><code>webpack</code> 是一个用于现代<code>JavaScript</code>应用程序的静态模块打包工具</p><ul><li>静态模块</li></ul><p>这里的静态模块指的是开发阶段，可以被 <code>webpack</code> 直接引用的资源（可以直接被获取打包进<code>bundle.js</code>的资源）</p><p>当 <code>webpack</code>处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限<code>js</code>文件），并生成一个或多个 <code>bundle</code></p><p><img src="https://static.vue-js.com/9ce194a0-a578-11eb-85f6-6fac77c0c9b3.png" alt="image"></p><h2 id="四、webpack的能力" tabindex="-1"><a class="header-anchor" href="#四、webpack的能力" aria-hidden="true">#</a> 四、Webpack的能力</h2><p><strong>编译代码能力</strong>，提高效率，解决浏览器兼容问题 <img src="https://static.vue-js.com/c5c2d360-a592-11eb-ab90-d9ae814b240d.png" alt="image"><strong>模块整合能力</strong>，提高性能，可维护性，解决浏览器频繁请求文件的问题 <img src="https://static.vue-js.com/d306d260-a592-11eb-ab90-d9ae814b240d.png" alt="image"><strong>万物皆可模块能力</strong>，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制 <img src="https://static.vue-js.com/e3c5a040-a592-11eb-ab90-d9ae814b240d.png" alt="image"></p><h2 id="五、webpack的打包原理" tabindex="-1"><a class="header-anchor" href="#五、webpack的打包原理" aria-hidden="true">#</a> 五、webpack的打包原理</h2><ol><li>读取配置项</li><li>识别入口文件</li><li>通过逐层识别模块依赖(Commonjs、amd或者es6的import，webpack都会对其进行分析，来获取代码的依赖)</li><li>webpack做的就是分析代码，转换代码，编译代码，输出代码</li><li>最终形成打包后的代码</li></ol><p>Webpack 有以下几个核心概念：</p><ul><li>Entry ：入口，Webpack 执行构建的第一步将从 entry 开始，可抽象成输入； Module：模块，配置处理模块的规则；在 Webpack 里一切皆模块，一个模块对应一个文件；Webpack 会从配置的 Entry 开始递归找出所有依赖的模块；</li><li>Loader：模块转换器，用于将模块的原内容按照需求转换成新内容；</li><li>Resolve：配置寻找模块的规则；</li><li>Plugin：扩展插件，在 Webpack 构建流程中的特定时机会广播对应的事件，插件可以监听这些事情的发生，在特定的时机做对应的事情；</li><li>Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果；</li><li>Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割；</li></ul><h2 id="六、其他相关问题" tabindex="-1"><a class="header-anchor" href="#六、其他相关问题" aria-hidden="true">#</a> 六、其他相关问题</h2><h2 id="问题列表webpack与grunt、gulp的不同-与webpack类似的工具还有哪些-谈谈你为什么最终选择-或放弃-使用webpack-有哪些常见的loader-他们是解决什么问题的-有哪些常见的plugin-他们是解决什么问题的-loader和plugin的不同-webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全是否写过loader和plugin-描述一下编写loader或plugin的思路-webpack的热更新是如何做到的-说明其原理-如何利用webpack来优化前端性能-提高性能和体验-如何提高webpack的构建速度-怎么配置单页应用-怎么配置多页应用-npm打包时需要注意哪些-如何利用webpack来更好的构建-如何在vue项目中实现按需加载" tabindex="-1"><a class="header-anchor" href="#问题列表webpack与grunt、gulp的不同-与webpack类似的工具还有哪些-谈谈你为什么最终选择-或放弃-使用webpack-有哪些常见的loader-他们是解决什么问题的-有哪些常见的plugin-他们是解决什么问题的-loader和plugin的不同-webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全是否写过loader和plugin-描述一下编写loader或plugin的思路-webpack的热更新是如何做到的-说明其原理-如何利用webpack来优化前端性能-提高性能和体验-如何提高webpack的构建速度-怎么配置单页应用-怎么配置多页应用-npm打包时需要注意哪些-如何利用webpack来更好的构建-如何在vue项目中实现按需加载" aria-hidden="true">#</a> 问题列表 webpack与grunt、gulp的不同？ 与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？ 有哪些常见的Loader？他们是解决什么问题的？ 有哪些常见的Plugin？他们是解决什么问题的？ Loader和Plugin的不同？ webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？ webpack的热更新是如何做到的？说明其原理？ 如何利用webpack来优化前端性能？（提高性能和体验） 如何提高webpack的构建速度？ 怎么配置单页应用？怎么配置多页应用？ npm打包时需要注意哪些？如何利用webpack来更好的构建？ 如何在vue项目中实现按需加载？</h2><ol><li>webpack与grunt、gulp的不同？</li></ol><p>三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。 grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。 webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。</p><p>所以总结一下： 从构建思路来说 gulp和grunt需要开发者将整个前端构建过程拆分成多个<code>Task</code>，并合理控制所有<code>Task</code>的调用关系 webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工 对于知识背景来说 gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路</p><hr><ol start="2"><li>与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？ 同样是基于入口的打包工具还有以下几个主流的： webpack rollup parcel 从应用场景上来看： webpack适用于大型复杂的前端站点构建 rollup适用于基础库的打包，如vue、react parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果 由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel</li></ol><hr><h2 id="_3-有哪些常见的loader-他们是解决什么问题的-file-loader-把文件输出到一个文件夹中-在代码中通过相对-url-去引用输出的文件url-loader-和-file-loader-类似-但是能在文件很小的情况下以-base64-的方式把文件内容注入到代码中去source-map-loader-加载额外的-source-map-文件-以方便断点调试image-loader-加载并且压缩图片文件babel-loader-把-es6-转换成-es5css-loader-加载-css-支持模块化、压缩、文件导入等特性style-loader-把-css-代码注入到-javascript-中-通过-dom-操作去加载-css。eslint-loader-通过-eslint-检查-javascript-代码" tabindex="-1"><a class="header-anchor" href="#_3-有哪些常见的loader-他们是解决什么问题的-file-loader-把文件输出到一个文件夹中-在代码中通过相对-url-去引用输出的文件url-loader-和-file-loader-类似-但是能在文件很小的情况下以-base64-的方式把文件内容注入到代码中去source-map-loader-加载额外的-source-map-文件-以方便断点调试image-loader-加载并且压缩图片文件babel-loader-把-es6-转换成-es5css-loader-加载-css-支持模块化、压缩、文件导入等特性style-loader-把-css-代码注入到-javascript-中-通过-dom-操作去加载-css。eslint-loader-通过-eslint-检查-javascript-代码" aria-hidden="true">#</a> 3.有哪些常见的Loader？他们是解决什么问题的？ file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 image-loader：加载并且压缩图片文件 babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 eslint-loader：通过 ESLint 检查 JavaScript 代码</h2><h2 id="_4-有哪些常见的plugin-他们是解决什么问题的-define-plugin-定义环境变量commons-chunk-plugin-提取公共代码uglifyjs-webpack-plugin-通过uglifyes压缩es6代码" tabindex="-1"><a class="header-anchor" href="#_4-有哪些常见的plugin-他们是解决什么问题的-define-plugin-定义环境变量commons-chunk-plugin-提取公共代码uglifyjs-webpack-plugin-通过uglifyes压缩es6代码" aria-hidden="true">#</a> 4.有哪些常见的Plugin？他们是解决什么问题的？ define-plugin：定义环境变量 commons-chunk-plugin：提取公共代码 uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</h2><h2 id="_5-loader和plugin的不同-不同的作用loader直译为-加载器-。webpack将一切文件视为模块-但是webpack原生是只能解析js文件-如果想将其他文件也打包的话-就会用到loader。-所以loader的作用是让webpack拥有了加载和解析非javascript文件的能力。plugin直译为-插件-。plugin可以扩展webpack的功能-让webpack具有更多的灵活性。-在-webpack-运行的生命周期中会广播出许多事件-plugin-可以监听这些事件-在合适的时机通过-webpack-提供的-api-改变输出结果。不同的用法loader在module-rules中配置-也就是说他作为模块的解析规则而存在。-类型为数组-每一项都是一个object-里面描述了对于什么类型的文件-test-使用什么加载-loader-和使用的参数-options-plugin在plugins中单独配置。-类型为数组-每一项是一个plugin的实例-参数都通过构造函数传入。" tabindex="-1"><a class="header-anchor" href="#_5-loader和plugin的不同-不同的作用loader直译为-加载器-。webpack将一切文件视为模块-但是webpack原生是只能解析js文件-如果想将其他文件也打包的话-就会用到loader。-所以loader的作用是让webpack拥有了加载和解析非javascript文件的能力。plugin直译为-插件-。plugin可以扩展webpack的功能-让webpack具有更多的灵活性。-在-webpack-运行的生命周期中会广播出许多事件-plugin-可以监听这些事件-在合适的时机通过-webpack-提供的-api-改变输出结果。不同的用法loader在module-rules中配置-也就是说他作为模块的解析规则而存在。-类型为数组-每一项都是一个object-里面描述了对于什么类型的文件-test-使用什么加载-loader-和使用的参数-options-plugin在plugins中单独配置。-类型为数组-每一项是一个plugin的实例-参数都通过构造函数传入。" aria-hidden="true">#</a> 5.Loader和Plugin的不同？ 不同的作用 Loader直译为&quot;加载器&quot;。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。 Plugin直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 不同的用法 Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</h2><p>6.webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全</p><h2 id="webpack-的运行流程是一个串行的过程-从启动到结束会依次执行以下流程初始化参数-从配置文件和-shell-语句中读取与合并参数-得出最终的参数-开始编译-用上一步得到的参数初始化-compiler-对象-加载所有配置的插件-执行对象的-run-方法开始执行编译-确定入口-根据配置中的-entry-找出所有的入口文件-编译模块-从入口文件出发-调用所有配置的-loader-对模块进行翻译-再找出该模块依赖的模块-再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理-完成模块编译-在经过第4步使用-loader-翻译完所有模块后-得到了每个模块被翻译后的最终内容以及它们之间的依赖关系-输出资源-根据入口和模块之间的依赖关系-组装成一个个包含多个模块的-chunk-再把每个-chunk-转换成一个单独的文件加入到输出列表-这步是可以修改输出内容的最后机会-输出完成-在确定好输出内容后-根据配置确定输出的路径和文件名-把文件内容写入到文件系统。在以上过程中-webpack-会在特定的时间点广播出特定的事件-插件在监听到感兴趣的事件后会执行特定的逻辑-并且插件可以调用-webpack-提供的-api-改变-webpack-的运行结果。" tabindex="-1"><a class="header-anchor" href="#webpack-的运行流程是一个串行的过程-从启动到结束会依次执行以下流程初始化参数-从配置文件和-shell-语句中读取与合并参数-得出最终的参数-开始编译-用上一步得到的参数初始化-compiler-对象-加载所有配置的插件-执行对象的-run-方法开始执行编译-确定入口-根据配置中的-entry-找出所有的入口文件-编译模块-从入口文件出发-调用所有配置的-loader-对模块进行翻译-再找出该模块依赖的模块-再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理-完成模块编译-在经过第4步使用-loader-翻译完所有模块后-得到了每个模块被翻译后的最终内容以及它们之间的依赖关系-输出资源-根据入口和模块之间的依赖关系-组装成一个个包含多个模块的-chunk-再把每个-chunk-转换成一个单独的文件加入到输出列表-这步是可以修改输出内容的最后机会-输出完成-在确定好输出内容后-根据配置确定输出的路径和文件名-把文件内容写入到文件系统。在以上过程中-webpack-会在特定的时间点广播出特定的事件-插件在监听到感兴趣的事件后会执行特定的逻辑-并且插件可以调用-webpack-提供的-api-改变-webpack-的运行结果。" aria-hidden="true">#</a> Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件； 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理； 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</h2><h2 id="_7-是否写过loader和plugin-描述一下编写loader或plugin的思路-loader像一个-翻译官-把读到的源文件内容转义成新的文件内容-并且每个loader通过链式操作-将源文件一步步翻译成想要的样子。编写loader时要遵循单一原则-每个loader只做一种-转义-工作。-每个loader的拿到的是源文件内容-source-可以通过返回值的方式将处理后的内容输出-也可以调用this-callback-方法-将内容返回给webpack。-还可以通过-this-async-生成一个callback函数-再用这个callback将处理后的内容输出出去。-此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。相对于loader而言-plugin的编写就灵活了许多。-webpack在运行的生命周期中会广播出许多事件-plugin-可以监听这些事件-在合适的时机通过-webpack-提供的-api-改变输出结果。" tabindex="-1"><a class="header-anchor" href="#_7-是否写过loader和plugin-描述一下编写loader或plugin的思路-loader像一个-翻译官-把读到的源文件内容转义成新的文件内容-并且每个loader通过链式操作-将源文件一步步翻译成想要的样子。编写loader时要遵循单一原则-每个loader只做一种-转义-工作。-每个loader的拿到的是源文件内容-source-可以通过返回值的方式将处理后的内容输出-也可以调用this-callback-方法-将内容返回给webpack。-还可以通过-this-async-生成一个callback函数-再用这个callback将处理后的内容输出出去。-此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。相对于loader而言-plugin的编写就灵活了许多。-webpack在运行的生命周期中会广播出许多事件-plugin-可以监听这些事件-在合适的时机通过-webpack-提供的-api-改变输出结果。" aria-hidden="true">#</a> 7.是否写过Loader和Plugin？描述一下编写loader或plugin的思路？ Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。 编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。 相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</h2><p>8.webpack的热更新是如何做到的？说明其原理？</p><p>webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。 原理：</p><p><img src="/assets/webpack_01.c3cce4b7.jpeg" alt="热更新原理"></p><p>首先要知道server端和client端都做了处理工作</p><p>第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</p><p>第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。</p><p>第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。</p><p>第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。</p><p>webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。</p><p>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</p><p>而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</p><h2 id="最后一步-当-hmr-失败后-回退到-live-reload-操作-也就是进行浏览器刷新来获取最新打包代码" tabindex="-1"><a class="header-anchor" href="#最后一步-当-hmr-失败后-回退到-live-reload-操作-也就是进行浏览器刷新来获取最新打包代码" aria-hidden="true">#</a> 最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码</h2><h2 id="_9-如何利用webpack来优化前端性能-提高性能和体验-用webpack优化前端性能是指优化webpack的输出结果-让打包的最终结果在浏览器运行快速高效。压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的uglifyjsplugin和paralleluglifyplugin来压缩js文件-利用cssnano-css-loader-minimize-来压缩css利用cdn加速。在构建过程中-将引用的静态资源路径修改为cdn上对应的路径。可以利用webpack对于output参数和各loader的publicpath参数来修改资源路径删除死代码-tree-shaking-。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数-optimize-minimize来实现提取公共代码。" tabindex="-1"><a class="header-anchor" href="#_9-如何利用webpack来优化前端性能-提高性能和体验-用webpack优化前端性能是指优化webpack的输出结果-让打包的最终结果在浏览器运行快速高效。压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的uglifyjsplugin和paralleluglifyplugin来压缩js文件-利用cssnano-css-loader-minimize-来压缩css利用cdn加速。在构建过程中-将引用的静态资源路径修改为cdn上对应的路径。可以利用webpack对于output参数和各loader的publicpath参数来修改资源路径删除死代码-tree-shaking-。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数-optimize-minimize来实现提取公共代码。" aria-hidden="true">#</a> 9.如何利用webpack来优化前端性能？（提高性能和体验） 用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css 利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径 删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现 提取公共代码。</h2><h2 id="_10-如何提高webpack的构建速度-多入口情况下-使用commonschunkplugin来提取公共代码通过externals配置来提取常用库利用dllplugin和dllreferenceplugin预编译资源模块-通过dllplugin来对那些我们引用但是绝对不会修改的npm包来进行预编译-再通过dllreferenceplugin将预编译的模块加载进来。使用happypack-实现多线程加速编译使用webpack-uglify-parallel来提升uglifyplugin的压缩速度。-原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度使用tree-shaking和scope-hoisting来剔除多余代码" tabindex="-1"><a class="header-anchor" href="#_10-如何提高webpack的构建速度-多入口情况下-使用commonschunkplugin来提取公共代码通过externals配置来提取常用库利用dllplugin和dllreferenceplugin预编译资源模块-通过dllplugin来对那些我们引用但是绝对不会修改的npm包来进行预编译-再通过dllreferenceplugin将预编译的模块加载进来。使用happypack-实现多线程加速编译使用webpack-uglify-parallel来提升uglifyplugin的压缩速度。-原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度使用tree-shaking和scope-hoisting来剔除多余代码" aria-hidden="true">#</a> 10.如何提高webpack的构建速度？ 多入口情况下，使用CommonsChunkPlugin来提取公共代码 通过externals配置来提取常用库 利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。 使用Happypack 实现多线程加速编译 使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度 使用Tree-shaking和Scope Hoisting来剔除多余代码</h2><h2 id="_11-怎么配置单页应用-怎么配置多页应用-单页应用可以理解为webpack的标准模式-直接在entry中指定单页应用的入口即可-这里不再赘述多页应用的话-可以使用webpack的-autowebplugin来完成简单自动化的构建-但是前提是项目的目录结构必须遵守他预设的规范。-多页应用中要注意的是-每个页面都有公共的代码-可以将这些代码抽离出来-避免重复的加载。比如-每个页面都引用了同一套css样式表随着业务的不断扩展-页面可能会不断的追加-所以一定要让入口的配置足够灵活-避免每次添加新页面还需要修改构建配置" tabindex="-1"><a class="header-anchor" href="#_11-怎么配置单页应用-怎么配置多页应用-单页应用可以理解为webpack的标准模式-直接在entry中指定单页应用的入口即可-这里不再赘述多页应用的话-可以使用webpack的-autowebplugin来完成简单自动化的构建-但是前提是项目的目录结构必须遵守他预设的规范。-多页应用中要注意的是-每个页面都有公共的代码-可以将这些代码抽离出来-避免重复的加载。比如-每个页面都引用了同一套css样式表随着业务的不断扩展-页面可能会不断的追加-所以一定要让入口的配置足够灵活-避免每次添加新页面还需要修改构建配置" aria-hidden="true">#</a> 11.怎么配置单页应用？怎么配置多页应用？ 单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述 多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是： 每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表 随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置</h2><p>12.npm打包时需要注意哪些？如何利用webpack来更好的构建？</p><p>Npm是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者，但是有些情况你也会去选择上传自己开发的模块。 关于NPM模块上传的方法可以去官网上进行学习，这里只讲解如何利用webpack来构建。 NPM模块需要注意以下问题： 要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。 Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。 Npm包大小应该是尽量小（有些仓库会限制包大小） 发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。 UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。</p><p>基于以上需要注意的问题，我们可以对于webpack配置做以下扩展和优化： CommonJS模块化规范的解决方案： 设置output.libraryTarget=&#39;commonjs2&#39;使输出的代码符合CommonJS2 模块化规范，以供给其它模块导入使用 输出ES5代码的解决方案：使用babel-loader把 ES6 代码转换成 ES5 的代码。再通过开启devtool: &#39;source-map&#39;输出SourceMap以发布调试。 Npm包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改.babelrc文件，为其加入transform-runtime插件 不能将依赖模块打包到NPM模块中的解决方案：使用externals配置项来告诉webpack哪些模块不需要打包。 对于依赖的资源文件打包的解决方案：通过css-loader和extract-text-webpack-plugin来实现，配置如下： const ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);</p><p>module.exports = { module: { rules: [ { // 增加对 CSS 文件的支持 test: /.css/, // 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ExtractTextPlugin.extract({ use: [&#39;css-loader&#39;] }), }, ] }, plugins: [ new ExtractTextPlugin({ // 输出的 CSS 文件名称 filename: &#39;index.css&#39;, }), ], };</p><hr><p>13.如何在vue项目中实现按需加载？ Vue UI组件库的按需加载 为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。 不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。 { &quot;presets&quot;: [[&quot;es2015&quot;, { &quot;modules&quot;: false }]], &quot;plugins&quot;: [ [ &quot;component&quot;, { &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; } ] ] }</p><p>单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。 通过import(<em>)语句来控制加载时机，webpack内置了对于import(</em>)的解析，会将import(<em>)中引入的模块作为一个新的入口在生成一个chunk。 当代码执行到import(</em>)语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: jingmin.jiang@cloudminds.com">jingmin.jiang</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: jingmin.jiang@cloudminds.com">jiangjingmin</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: 1143480553@qq.com">kyxiao</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/posts/fe/webpack/babel.html" class="" aria-label="Babel"><!--[--><!--]--> Babel <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.6e1280c8.js" defer></script>
  </body>
</html>
