(window.webpackJsonp=window.webpackJsonp||[]).push([[235],{606:function(e,v,_){"use strict";_.r(v);var t=_(28),a=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"vue-和-react-区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue-和-react-区别"}},[e._v("#")]),e._v(" Vue 和 React 区别")]),e._v(" "),_("p",[e._v("这里就做几个简单的类比吧，当然没有好坏之分，只是使用场景不同")]),e._v(" "),_("h3",{attrs:{id:"相同点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[e._v("#")]),e._v(" 相同点")]),e._v(" "),_("ul",[_("li",[e._v("都有组件化思想")]),e._v(" "),_("li",[e._v("都支持服务器端渲染")]),e._v(" "),_("li",[e._v("都有Virtual DOM（虚拟dom）")]),e._v(" "),_("li",[e._v("数据驱动视图")]),e._v(" "),_("li",[e._v("都有支持native的方案："),_("code",[e._v("Vue")]),e._v("的"),_("code",[e._v("weex")]),e._v("、"),_("code",[e._v("React")]),e._v("的"),_("code",[e._v("React native")])]),e._v(" "),_("li",[e._v("都有自己的构建工具："),_("code",[e._v("Vue")]),e._v("的"),_("code",[e._v("vue-cli")]),e._v("、"),_("code",[e._v("React")]),e._v("的"),_("code",[e._v("Create React App")])])]),e._v(" "),_("h3",{attrs:{id:"区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[e._v("#")]),e._v(" 区别")]),e._v(" "),_("ul",[_("li",[e._v("数据流向的不同。"),_("code",[e._v("react")]),e._v("从诞生开始就推崇单向数据流，而"),_("code",[e._v("Vue")]),e._v("是双向数据流")]),e._v(" "),_("li",[e._v("数据变化的实现原理不同。"),_("code",[e._v("react")]),e._v("使用的是不可变数据，而"),_("code",[e._v("Vue")]),e._v("使用的是可变的数据")]),e._v(" "),_("li",[e._v("组件化通信的不同。"),_("code",[e._v("react")]),e._v("中我们通过使用回调函数来进行通信的，而"),_("code",[e._v("Vue")]),e._v("中子组件向父组件传递消息有两种方式：事件和回调函数")]),e._v(" "),_("li",[e._v("diff算法不同。"),_("code",[e._v("react")]),e._v("主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。"),_("code",[e._v("Vue")]),e._v(" 使用双向指针，边对比，边更新DOM")])])])}),[],!1,null,null,null);v.default=a.exports}}]);