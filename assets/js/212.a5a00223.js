(window.webpackJsonp=window.webpackJsonp||[]).push([[212],{606:function(t,e,v){"use strict";v.r(e);var _=v(28),o=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"计算属性-vs-监听属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算属性-vs-监听属性"}},[t._v("#")]),t._v(" 计算属性 VS 监听属性")]),t._v(" "),v("h2",{attrs:{id:"computed"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[t._v("#")]),t._v(" Computed")]),t._v(" "),v("blockquote",[v("p",[t._v("computed是计算属性，类似于过滤器，对绑定到视图的数据进行处理，并监听变化进而执行对应的方法。")])]),t._v(" "),v("ol",[v("li",[v("code",[t._v("computed")]),t._v(" 是计算属性，也就是计算值，它更多用于计算值的场景")]),t._v(" "),v("li",[v("code",[t._v("computed")]),t._v("具有缓存性，"),v("code",[t._v("computed")]),t._v("的值在"),v("code",[t._v("getter")]),t._v("执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取"),v("code",[t._v("computed")]),t._v("的值时才会重新调用对应的"),v("code",[t._v("getter")]),t._v("来计算")]),t._v(" "),v("li",[v("code",[t._v("computed")]),t._v("适用于计算比较消耗性能的计算场景")])]),t._v(" "),v("h2",{attrs:{id:"watch"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" Watch")]),t._v(" "),v("blockquote",[v("p",[t._v("watch是一个侦听的动作，用来观察和响应 Vue 实例上的数据变动。")])]),t._v(" "),v("ol",[v("li",[t._v("更多的是「观察」的作用，类似于某些数据的监听回调，用于观察"),v("code",[t._v("props")]),t._v(" "),v("code",[t._v("$emit")]),t._v("或者本组件的值，当数据变化时来执行回调进行后续操作")]),t._v(" "),v("li",[t._v("无缓存性，页面重新渲染时值不变化也会执行")]),t._v(" "),v("li",[t._v("浅监听，引用类型拿不到oldValue，需要使用handler、deep: true")])]),t._v(" "),v("p",[t._v("属性：handler、immediate、deep")]),t._v(" "),v("p",[v("strong",[t._v("小结:")])]),t._v(" "),v("ol",[v("li",[t._v("当我们要进行数值计算，而且依赖于其他数据，那么把这个数据设计为"),v("code",[t._v("computed")])]),t._v(" "),v("li",[t._v("如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化")])])])}),[],!1,null,null,null);e.default=o.exports}}]);