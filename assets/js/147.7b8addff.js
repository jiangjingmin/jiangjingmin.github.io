(window.webpackJsonp=window.webpackJsonp||[]).push([[147],{544:function(t,n,s){"use strict";s.r(n);var a=s(28),e=Object(a.a)({},(function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"var-、let-和-const-区别-实现原理是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#var-、let-和-const-区别-实现原理是什么"}},[t._v("#")]),t._v(" var 、let 和 const 区别？实现原理是什么？")]),t._v(" "),s("p",[t._v("通过 var 创建的变量只有函数作用域，而通过 let 和 const 创建的变量既有函数作用域，也有块作用域。")]),t._v(" "),s("h2",{attrs:{id:"三者的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三者的区别"}},[t._v("#")]),t._v(" 三者的区别")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("var 和 let 用以声明变量，const 用于声明只读的常量；")])]),t._v(" "),s("li",[s("p",[t._v("var 声明的变量，不存在块级作用域，在全局范围内都有效，let 和 const\n声明的，只在它所在的代码块内有效；")])]),t._v(" "),s("li",[s("p",[t._v("let 和 const 不存在像 var 那样的 “变量提升” 现象，所以 var 定义变\n量可以先使用，后声明，而 let 和 const 只可先声明，后使用；")])]),t._v(" "),s("li",[s("p",[t._v("let 声明的变量存在暂时性死区，即只要块级作用域中存在 let，那么它\n所声明的变量就绑定了这个区域，不再受外部的影响。")])]),t._v(" "),s("li",[s("p",[t._v("let 不允许在相同作用域内，重复声明同一个变量；")])]),t._v(" "),s("li",[s("p",[t._v("const 在声明时必须初始化赋值，一旦声明，其声明的值就不允许改变，\n更不允许重复声明；如 const 声明了一个复合类型的常量，其存储的是一个引\n用地址，不允许改变的是这个地址，而对象本身是可变的。")])])]),t._v(" "),s("h2",{attrs:{id:"实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[t._v("#")]),t._v(" 实现原理")]),t._v(" "),s("blockquote",[s("p",[t._v("变量与内存之间的关系，主要由三个部分组成：")])]),t._v(" "),s("ul",[s("li",[t._v("变量名、内存地址、内存空间\n**JS 引擎在读取变量时，先找到变量绑定的内存地址，然后找到地址所指向的内\n存空间，最后读取其中的内容。**当变量改变时，JS 引擎不会用新值覆盖之前旧\n值的内存空间（虽然从写代码的角度来看，确实像是被覆盖掉了），而是重新\n分配一个新的内存空间来存储新值，并将新的内存地址与变量进行绑定，JS 引\n擎会在合适的时机进行 GC，回收旧的内存空间。\nconst 定义变量（常量）后，变量名与内存地址之间建立了一种不可变的绑定\n关系，阻隔变量地址被改变，当 const 定义的变量进行重新赋值时，根据前面\n的论述，JS 引擎会尝试重新分配新的内存空间，所以会被拒绝，便会抛出异常。")])])])}),[],!1,null,null,null);n.default=e.exports}}]);